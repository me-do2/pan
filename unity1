unity
#6
Unityのバージョンについて
		　  マイナーバージョン
　　　　　　  ↓
Unity 2020.1.1f1←ビルドバージョン
	  ↑西暦↑
		　メジャーバージョン(4だと長期サポートされる)LTS版
alpha,beta,fix版か


#12
リジッドボディ　重力　
Collider 当たり判定　コンポーネント

物理演算
物体をはねさせる　プロジェクト右→作成→物理マテリアル　バウンズネス１
スフィアコライダーのマテリアルに物理マテリアルをドラック＆ドロップ

#13
プログラミング　C#　ビジュアルスタジオ
スクリプトをキューブにあどどコンポーネント
実体化＝インスタンス化 デバッグログ　コンソール

Debug.Log("かえるちゃん");
デバッグログに書き出す
transform.position += Vector3.right;
トランスフォームポジション　右にものすごいスピードで動かす　毎フレームXに1足す


#14
フレームとは　画像１→画像２（１フレーム）
フレームレートとは　１秒間に何回画像を出力できるか　FPS（frame per second） 60FPS(1秒間に60回画像を出力)　ディスプレイの画面更新に合わせている
60→30→15→10→5→0　フレームレートが変動するとガクつく
プレーヤーがどう入力するかわからないので画面に表示してからでないと計算できない
ゲームの移動は点の移動　当たり判定をすり抜ける場合がある　物理演算で事前に計算する設定があるが重い　全ての移動は瞬間移動　間に補完が入るかどうか

＃15
同じタイミングで呼ばれるメソッドはどのような順序で呼ばれてもいいようにしよう
プログラムの実行順序　順序結果が変わる

＃16
変数とは　いろんなところで使い回せる　おお（変数（名前））よ！死んでしまうとはなにごとじゃ！
int a = 1;  整数系の変数　「int」にaと名付けて中に１を入れる　どのような種類を使うか（型）　なんという名前を付けるか　中身に何を入れるか（省略可）　自分で定義して使う
int a = 1;  Debug.Log(a); 　デバッグログにaではなく１と表示される（変数の中身がログに表示される）
赤字エラーは　プログラムの書き方が違う　コンソールのログをダブルクリックすると間違っているところに飛べる
public{int 下OK   void{int 下エラー　範囲＝スコープ　２つの変数が定義されていたらメソッド内（すぐ上に記載したもの）の変数が優先される（メソッド内（void内が有効で他は無視される））　スコープが狭い方が有効になる
基本的な型
int型		整数
float型	有効桁数７桁の浮動小数		1.234567
double型	有効桁数１６桁の浮動小数
char型	１文字
string型	文字列
bool型	真か偽か

string name = "かえるちゃん”;／／本来入力してもらったものを保存しておく
Debug.Log("おお" + name + "よ！");
Debug.Log("暑いとは　なにごとじゃ！");


=====================================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class test: MonoBehaviour
{
    string name = "かえるちゃん";

    // Start is called before the first frame update
    void Start()
    {

        Debug.Log("おお" + name + "よ！");
        Debug.Log("暑いとは　なにごとじゃ！");
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
=======================================

＃17
C#　オブジェクト指向型　設計図class  →　実体インスタンス　public class test : MonoBehaviour
															　↑この中で定義されている　※正確にはMonoBehaviourがさらに継承している先で定義されている
クラス型変数
transform.position += Vector3.right;
↑変数　　　↑変数　　　　　　　↑変数
↑Transform型
↑class
↑using UnityEngine
↑アドレスが入っている
設計図の中に別の設計図の実体を動かす仕組みを作ることができる
.(ドット)はTransformクラスの中の変数positionにアクセス
positionはVector3型
Vector3型
x　float型
y　float型
z　float型
コンポーネントとは　モジュール　コンポーネントではないクラス（設計図）もある　コンポーネントは全てクラス　オブジェクトはモノ
コンポーネントはスクリプトからコントロールできる

Vector3.rightはstatic変数　クラスではなく構造型(設計図)struct
クラスは参照型　構造型は値型


＃18　計算をしてみよう　基本的な演算
算術演算子
int a;
a = 1 + 1; 	// 2 	足し算
a = 1 - 1; 	// 0 	引き算
a = 1 * 1; 	// 1 	掛け算
a = 1 / 1; 	// 1 	割り算
a = 1 % 1; // 0 	余り％
C#では＝は代入する　右辺を計算して左辺に代入する　
int b = 1;
b = b + 1; //2
b += 1; 同じ変数（b）なら省略できる
==等しい　　!=等しくない
transform.position += Vector3.right;
↓本来は
transform.position = transform.position + Vector3.right;
b -= 1;
b *= 1;
b /= 1;
b %= 1;

b = b + 1;
同じ変数（b）かつ１なら省略できる
++b; 	b++;		インクリメント演算子
—b;		b—;		デクリメント演算子
++変数、—変数　１の足し引きを先に行う
変数++、変数—　１の足し引きを後で行う
int型は小数点以下切り捨て
int a = 1 / 2; //0
float a = 1 / 2; //0　1と2が整数なのでintと認識してしまう
float a = (float)1 / (float)2; // 0.5　キャスト（型名）変数もしくは値
float a = 1f / 2f; // 0.5　サフィックス　数値の最後に型の頭文字を書いて型を表す　計算の際に何の型なのか明示してあげる必要がある
明示なしの整数→int型
明示なしの少数→double型
float b = 0.5f / 0.1f;
double b = 0.5 / 0.1;
double b = 0.5f / 0.1f;　でかい箱から小さい箱はエラーにならない

string a = “あいうえお” + “かきくけこ” + 1 + 2;　あいうえおかきくけこ12 　　文字列として扱われる
char a = “あ”　char型で””を使うとエラーとなる
char a = ‘あ’	一文字はシングルクォーテーション
char a = (ahar)(‘あ’  + ’い’);　キャスト（char）を入れないとエラーとなる　ひらがなの中身は文字コードなので数字になっている


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class test: MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        int playerHp = 100;
        int playerAtk = 50;

        int bossHp = 100;
        int bossAtk = 20;

        Debug.Log("魔王が現れた！");
        Debug.Log("勇者HP" + playerHp);
        Debug.Log("魔王HP" + bossHp);

        Debug.Log("勇者の攻撃　魔王に" + playerAtk + "のダメージを与えた");
        Debug.Log("魔王の攻撃　勇者に" + bossAtk + "のダメージを与えた");

        playerHp -= bossAtk;
        bossHp -= playerAtk;


        Debug.Log("勇者HP" + playerHp);
        Debug.Log("魔王HP" + bossHp);

        Debug.Log("勇者の攻撃　魔王に" + playerAtk + "のダメージを与えた");
        Debug.Log("魔王の攻撃　勇者に" + bossAtk + "のダメージを与えた");

        playerHp -= bossAtk;
        bossHp -= playerAtk;

        Debug.Log("魔王のHPが" + bossHp + "になった。魔王をやっつけた！");
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

#19　メソッドを使ってみよう
メソッド　void Start Update ←Unity側から呼ばれている特別なメソッド
void 何も返さない
<メソッド>
呼び出される　＞　直ちに実行
処理が終わる　＞　呼び出し元に返る
この一連の流れは1フレーム内で行われる
aaa();メソッドの呼び出しは何回でも実行できる
aaa();
aaa();
スコープの範囲で適応される

========================================================
void Start()
{
aaa(1);
aaa(2);
aaa(3);				←データが渡される		型があっていればいろんなデータを送れる
}					↓
					↓
void aaa(int b)			←引数（バトン）変数（箱の名前）
{
	Debug.Log(b);
}
========================================================

＜参照型の場合＞変数は別でも中身が一緒なので注意　←変数の中に実体のアドレスが入っているタイプの型
スコープの範囲がかぶった場合、スコープが狭い方が優先される
引数は「,」で区切ると複数定期できる　
========================================================
void Start()
{
aaa(1,2,3);			←複数データを渡せる　ログは６
}
void aaa(int a,int b, int c)
{
	Debug.Log(a + b + c);
}

voidをintに変更しreturnで返すようにする
void Start()
{
	int d = aaa(1,2,3);			←　③returnがデータを返す　④返ってきたデータを代入←代入しないと結果はでない　
	Debug.Log(d);					ログは６
}
int aaa(int a,int b, int c)			←　①返すデータの型
{
	return a + b + c;			←　②定義した型と同じ型のデータ　リターンでデータを返すとメソッドの処理終わり
	Debug.Log("aaa");			←　ログは呼ばれない
}
========================================================

========================================================
void Start()
{
	int b = 0;
	b = aaa(b);				←③１を代入
	b = aaa(b);				←⑥２を代入
	b = aaa(b);				←⑨３を代入
	Debug.Log(d);				←⑩ログは３
}
int aaa(int b)					←①０を渡す④１を渡す⑦２を渡す
{
	return ++b;				←②１を返す⑤２を返す⑧３を返す
}
========================================================
わかりやすい変数名をつけてね！※解説のために名前を被せています


メソッドを追加void Turn() Turn();Turn(); intのスコープを大きくして省略化
==================================================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class test : MonoBehaviour
{
    int playerHp = 100;
    int playerAtk = 50;
    int bossHp = 100;
    int bossAtk = 20;

    // Start is called before the first frame update
    void Start()
    {

        Debug.Log("魔王が現れた！");
        Turn();
        Turn();
        Debug.Log("魔王のHPが" + bossHp + "になった。魔王をやっつけた！");
    }

    void Turn()
    {
        Debug.Log("勇者HP" + playerHp);
        Debug.Log("魔王HP" + bossHp);

        Debug.Log("勇者の攻撃　魔王に" + playerAtk + "のダメージを与えた");
        Debug.Log("魔王の攻撃　勇者に" + bossAtk + "のダメージを与えた");

        playerHp -= bossAtk;
        bossHp -= playerAtk;
    }

    // Update is called once per frame
    void Update()
    {

    }
}
========================================================


#２０　条件分岐をやってみよう（if文）

========================================================
    void Start()
    {

        int a = 1;				←変数を代入
        if (a > 0)				←if(条件）
        {
            Debug.Log("通った");	←｛カッコ内｝条件を満たした場合のみ実行される
        }

    }
========================================================

＜条件式＞
A == B	AとBは等しい
A != B	AとBは等しくない
A < B	AはBより小さい　AとBは等しくない（＝が入っていないので等しい場合は条件に当てはまわらない）
A > B	AはBより大きい　AとBは等しくない
A <= B	AはB以下　AとBは等しい　必ず＝は右側
A >= B	AはB以上　AとBは等しい

条件を満たさなかった場合はスキップされる

========================================================
void Start()
    {

        int a = 1;
        if (a < 0)
        {
            Debug.Log("上を通った");
        }
        else						条件を満たさなかったので下を通ったがログに表示される
        {
            Debug.Log("下を通った");
        }
    }
========================================================

========================================================
void Start()
    {

        int a = 1;
        if (a < 0)
        {
            Debug.Log("上を通った");
        }
        else if(a > 0)				条件を満たすので真ん中を通ったがログに表示される
        {
            Debug.Log("真ん中を通った");
        }

        else
        {
            Debug.Log("下を通った");
        }
    }
========================================================

========================================================
void Start()
    {

        int a = 1;
        if (a > 0)						条件○	
        {
            Debug.Log("上を通った");			上と真ん中の条件を満たしていると上に書いてある一番上の上を通っただけ実行される
        }
        else if(a == 1)					条件○	
        {
            Debug.Log("真ん中を通った");
        }

        else							条件✗
        {
            Debug.Log("下を通った");
        }
    }
========================================================

条件式の型
bool型
真か偽かを表す
２種類の値しか入れられない
true		真○
false		偽✗
＜例＞bool a = true;

========================================================
void Start()
    {

        int a = 1;
        bool jouken1 = a > 0;
        bool jouken2 = a == 1;

        if(jouken1)
        {
            Debug.Log("上を通った");
        }
        else if(jouken2)
        {
            Debug.Log("真ん中を通った");
        }

        else
        {
            Debug.Log("下を通った");
        }
    }
========================================================

複数の条件を書く
&と|は論理演算と言う

int a = 2;
if(a > 0 & a <2)		左○右✗でfalse
bool型&bool型（アンド）
trueかつtrueで真　	片方でもfalseなら偽

else if( a > 0 | a < 2)	左○右✗でtrue
bool型|bool型（パイプ）
trueまたはtrueで真	どちらか一方がtrueなら真　両方がfalseなら偽
========================================================
public class test : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {

        int a = 2;

        if(a > 0 && a < 2)
        {
            Debug.Log("上を通った");
        }
        else if(a > 0 | | a < 2)
        {
            Debug.Log("真ん中を通った");	//このログが表示される
        }

        else
        {
            Debug.Log("下を通った");
        }
    }

    // Update is called once per frame
    void Update()
    {

    }
}
========================================================
＜短絡評価＞
＆＆　｜｜		記号を２回連続で書く　左側を見るだけで確定した場合　右側を見ない　処理の無駄が省ける！

========================================================

public class test : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {

        int a = 1;
        int b = 2;

        if((a > 0 && b < 0) && (a == 1 && b == 2))
        {
            Debug.Log("上を通った");
        }
        else if((a < 0 || b > 0) || (a != 1 || b != 2))	//b＞０が条件に一致する
        {
            Debug.Log("真ん中を通った");
        }
        else
        {
            Debug.Log("下を通った");
        }
    }

    // Update is called once per frame
    void Update()
    {

    }
}
========================================================

（）をつけなくてもできるが｜があると読みづらいので（）を使うのがオススメ

switch文
switch(比較対象)
{					⇅一致した場合
	case 比較するもの:
		 処理内容				←処理を行う
		 break;
}

switch (a)
{					⇅aが0の場合
	case 0:
		Debug.Log(“aは0です”);	←処理を行う
		break;
}


========================================================

public class test : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {

        int a = 1;

        switch (a)
        {
            case 0:
                Debug.Log("aは0です");
                break;
            case 1:
                Debug.Log("aは1です");			//aは１です
                break;
            case 2:
                Debug.Log("aは2です");
                break;
            case 3:
            case 4:
                Debug.Log("aは3もしくは4です");
                break;
            default:
                Debug.Log("aは01234以外です");
                break;
        }
    }

    // Update is called once per frame
    void Update()
    {

    }
}
========================================================
条件式はtrueかfalseしかない
＜if文、switch文＞
状況に応じて使い分けよう

↓下記のコードはswitch文よりif文を使ったほうが良い　
========================================================

int a = 1;
int b = 2;

switch (a == b)
{
	case true:
		break;
	case false:
		break;
}
========================================================

========================================================

public class test : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {

        int a = 1;
        int b = 2;

        switch (a == b)
        {
            case true:
                Debug.Log("真");
                break;
            case false:
                Debug.Log("偽");
                break;
        }
    }

    // Update is called once per frame
    void Update()
    {

    }
}
========================================================


#21　ループ文を書いてみよう　
while(bool型)ホワイルループ
{
　ループ中身
}
========================================================

void Start()
    {

        int a = 0;
        while(a < 5)		//trueの場合処理される
        {
            Debug.Log("aは" + a + "です");
            ++a;
        }
        
    }
========================================================
条件が5 < 5 falseになると次の処理へ

Unityがフリーズする無限ループに気をつける　強制終了しかなくなる　保存してないデータが消えてしまう　終われるような条件にしよう
int a = 0;
bool b = a < 5;		←ループ外で代入している
while(b)			←条件が一生true   bに値を入れ直していないのでbがずっと変わらないままになってしまう
{
            Debug.Log("aは" + a + "です");
            ++a;
	　b = a < 5;	←ループ毎に更新される　これを入れれば無限ループにならない　ｂに値を入れてあげる
 }

Updateとの違い
Update　＞　毎フレーム呼ばれるメソッド		□	□	□	□	□	（4フレーム）　
ループ文　＞　１フレーム内で完結する命令		□				□	（1フレーム）　※例外あり
========================================================

void Start()
    {
        int a = 0;
        while(transform.position.x < 5)
        {
            Debug.Log("このCubeのx座標は" + transform.position.x + "です");
            transform.position += Vector3.right;     //Xが５になるまで足す処理
        }
        
    }
========================================================

continue とbreak
========================================================

void Start()
    {
        int a = 0;
        while (true)		//絶対にループする
        {
            ++a;
            if(a < 10)		//1 < 10 true　++aを繰り返す　　10 < 10 falseになると次の処理に移る→ログを表示→break
            {
                continue;		//trueならwhileに戻る
            }
            Debug.Log(a);	
            break;			//ループ文を抜ける
        }
        
    }
========================================================

do while文
=====================  falseとなる為、一度も実行されない
 void Start()
    {
        int a = 0;
        while (a > 5)
        {
            ++a;
            Debug.Log(a);
        }
        
    }
=====================

do に書き換えて　whileを下にもっていき；をつけると一回実行される
=====================
void Start()
    {
        int a = 0;
        do
        {
            ++a;			//処理を行ってから
            Debug.Log(a);
        }
        while (a > 5);		//条件の判定を行う
    }
=====================

for文
=====================
void Start()
    {
        for(int i = 0; i < 5; ++i)
        {
            Debug.Log(i);
        }
    }
=====================
for(
int i = 0;　←最初に１度だけ行う処理を書く　←変数の定義を書く事が多い　iを０として定義している
 i < 5;	←ループする条件　条件判定が行われてiが5よりも小さいのでtrue 0 < 5 true→ログ吐き出し　5 < 5 falseになるとループ文を抜ける
 ++i)		←処理が終わるたびに行う処理　ログ吐き出し後に　i 0→1
３つの項目は好きなように書き換えて大丈夫



while文(上と全く同じ処理だがfor文を使ったほうがコンパクトで無限ループも防ぎやすい)
=====================
int i =0;
while(i < 5)
{
	Debug.Log(i);
	++i;
}
=====================

for( ; ; )		←無限ループ
{
}
while (true)
{
}


#22　配列を使ってみよう
変数　データを入れる箱
配列　複数の箱をまとめたもの
＜配列を定義＞
型[ ] 　配列名　=　new　型[要素数]；
↑↑		↑		↑　↑	↑
何も書かなくて大丈夫	　　
↑	　	↑		↑
↑		好きな名前　※一部例外あり
↑				↑
↑				＝でつなぎ新しく作るという意味
同じ型			　同じ型　
						↑
						いくつデータが入るか　数は整数になる

int[] a = new int[3];
			  ↑
			  int型のデータが３つ入る
int[] a = new int[3];
a[0] = 1;
a[1] = 2;
a[2] = 3;
   ↑
　何番目に入れるか　配列は０から始まる　[□□□]
								０１２　←３つのデータ
a[3] = 4; //エラー
a = 1;  //エラー

このような書き方もできる
int [] a = { 1, 2, 3};
		0  1  2  ←データ[ ]
大きいデータ
int[] a = new int[50];
			   ↑
			　この数のデータを入れるのは大変　そのような時はループ文を使う
int[] a = new int[50];
for(int i = 0; i < a.Length; ++i)
{				↑
	a[i] = i;		↑   //配列の最初から最後までの値を入れている　ここを変えれば色々なデータを入れられる
}				↑
				「配列.Length」配列の要素数を返す（50）

多次元配列
int[,,] a = new int[3, 4, 2];
　  ↑				↑
「,」で区切る
[3, 4, 2]	□１データ	
   01  01  01
0□□□□□□
1□□□□□□
2□□□■□□
3□□□□□□
    0     1    2
a[1,2,1]■となる

=====================
void Start()
    {
        int[,,] a = new int[3, 4, 2]
                {
			//↓２つのデータ
                   { { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 } },　//4セットが３セット　書くのがシンドイので可能ならループ文を使おう
                   { { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 } },
                   { { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 } }
                };
    }
=====================
=====================
int[,,] a = new int[3, 4, 2];
				↑
				ここの数がわからないとループ文が作りづらい

        int[,,] a = new int[3, 4, 2];

        Debug.Log(a.Length);	//配列の総数３×４×２＝２４
        Debug.Log(a.GetLength(1));	//1は"０１２←データ[ 3, 4, 2]に当てはまる　指定したところの数４　配列の変更（数字の変更）を後で行った場合数字を直打ちだと修正が入るから使う
=====================

配列.GetLength(知りたい数)
この状態で実行すると２４と４になる
＜プログラミングの基本＞
数字直打ちはなるべく避けよう！

=====================
void Start()
    {
        int[,,] a = new int[3, 4, 2];

        for(int i = 0; i < a.GetLength(0); ++i)
        {
            for(int j = 0; j < a.GetLength(1); ++j)
            {
                for(int k = 0; k < a.GetLength(2); ++k)
                {
                    a[i, j, k] = i + j + k; //代入　（今回は適当な値を入れている）
                    Debug.Log("a[" + i + "," + j + "," + k + "]に代入する");
                }
            }
        }
    }
=====================
a[0,0,0]に代入する
a[0,0,1]に代入する
a[0,1,0]に代入する
a[0,1,1]に代入する
a[0,2,0]に代入する
a[0,2,1]に代入する
a[0,3,0]に代入する
a[0,3,1]に代入する
a[1,0,0]に代入する
a[1,0,1]に代入する
a[1,1,0]に代入する
a[1,1,1]に代入する
a[1,2,0]に代入する
a[1,2,1]に代入する
a[1,3,0]に代入する
a[1,3,1]に代入する
a[2,0,0]に代入する
a[2,0,1]に代入する
a[2,1,0]に代入する
a[2,1,1]に代入する
a[2,2,0]に代入する
a[2,2,1]に代入する
a[2,3,0]に代入する
a[2,3,1]に代入する
UnityEngine.Debug:Log(Object)
test:Start() (at Assets/test.cs:19)

[3, 4, 2]　24個の配列結果が見れる

foreach フォアい～ち
＜foreach文＞
複数の要素を持つものを順番に取り出してくれるループ文
foreach(仮の入れ物　in 取り出し元)
{
}

=====================
void Start()
    {
        int[] a = { 1, 2, 3, 4, 5 };　//int 配列にはいっているものは同じ型
        foreach(int i in a) //①aの中を取り出そうとしている　②取り出したもの１を仮の変数iに入れる
        {
            Debug.Log(i);　//③（）の中に入る　i←1　④処理が終わったらループする　２〜５へ　全ての要素を取り出すまでループする　全ての要素を取り出したら抜ける
        }

    }
=====================

＃23　インスタンスを取得しよう
さまざまなものへのアクセス方法
C#　＞　オブジェクト指向型
設計図class →　実体インスタンス　設計図を元に作成
コンポーネント（Transformなど）としてインスタンス化していた　transformの場合はこのインスタンスのアドレスが変数Transformに入っていた　Unityが全部やってくれてた
今回は自分で変数を定義して自分で中身を入れてみよう

Box Colliderを取得して変数に入れてみる

=====================

public class test : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        BoxCollider box = null;				//取得したいコンポーネントの型を書く　コンポーネントの型名は大体インスペクターに書いてあった名前と同じ　null 変数の中を空にする
        Debug.Log(box);					//Null
        box = GetComponent<BoxCollider>();
        Debug.Log(box);					//Cube
    }
=====================
GetComponent＜型名＞();　ゲームオブジェクトについているコンポーネントを取得する命令　※MonoBehaviour（モノビヘイビア）を継承しているので使える
今書いているスクリプトと同じゲームオブジェクトの中から指定した型と同じコンポーネントのアドレスを取得して変数（box）に代入する
！同じ型のコンポーネントが複数あるとどれを取得するかがわからない
<GetComponent>アドレスを取得することでコンポーネントにアクセスできる

GameObjectを取得してみよう

GameObject.Find("");
※大文字		　　↑
			　　ゲームオブジェクト名
指定した名前のゲームオブジェクトのインスタンスのアドレスを取得できる　using Untiy Engine;のおかげで使用できる

=====================

void Start()
    {
        GameObject g = null;
        Debug.Log(g);							//Null
        g = GameObject.Find("Directional Light");
        Debug.Log(g);							//Directional Light
    }
=====================
<GameObject.Find()>
アドレスを取得することでゲームオブジェクトにアクセスできる

他のゲームオブジェクトのコンポーネントを取得
Directional LightのLightを取得する
=====================

void Start()
    {
        GameObject g = null;
        Light l = null;
        Debug.Log(g);							//Null
        Debug.Log(l);							//Null
        g = GameObject.Find("Directional Light");
        l = g.GetComponent<Light>();			//Directional Lightにアクセス　Directional Lightの中のLightコンポーネントを取得
        Debug.Log(g);							//Directional Light  (UnityEngine.GameObject)
        Debug.Log(l);							//Directional Light  (UnityEngine.Light)
    }
=====================
"Directional Light" →　"DirectionalLight"　スペースを消すとエラーとなる　NullReferenceException cs:15←15行目でエラー
名前指定はスペースも合わせる必要がある
＜NullReferenceException＞
何もないところにアクセスしようとしている
=====================

void Start()
    {
        GameObject g = null;
        Light l = null;
        g = GameObject.Find("DirectionalLight");	←Findが失敗
        Debug.Log(g);							//Null　GameObject.Find　GetComponent失敗するとNullが返ってくる
        l = g.GetComponent<Light>();			←空っぽにアクセスしようとしている＜NullReferenceException＞
        Debug.Log("確認");						←エラー以降は実行されない
    }
=====================

インスタンスを作成　当たり判定3倍　コンポーネントにアクセスしてパラメータをスクリプトから変更できる　←ゲーム中にパラメータを変更できる
=====================

void Start()
    {
        Vector3 v = new Vector3();						//newでインスタンス作成　目に見える形ではなくメモリ上に存在する
        v.x = 3;
        v.y = 3;
        v.z = 3;

        BoxCollider box = GetComponent<BoxCollider>();
        box.size = v;
    }
=====================
設計図を元に作成
設計図　→　実体インスタンス
↑
みたいな型と配列はnewできる
コンポーネントもnewできるが、ゲームオブジェクトに付いてないとStartとUpdateは呼ばれない
構造体も設計図から実体化させる形なのでnewできる


＃24　値型と参照型
データの取り扱い方
＜型の種類＞　データの取り扱いが違う

参照型	メモリのアドレスを取り扱う
値型		データを直接取り扱う

↓ちゃんとキューブが移動する↓参照型　アドレスでデータを扱う型
=====================

public class test : MonoBehaviour
{
    Transform t;

    // Start is called before the first frame update
    void Start()
    {
        t = transform;								//transformのアドレスが変数tに代入される
    }
    // Update is called once per frame
    void Update()
    {
        t.position += Vector3.right;					//ちゃんとtransformのポジションに渡している
    }

}
=====================

↓動かない　値型　それぞれ（v と position）が実データを持つ
=====================

public class test : MonoBehaviour
{
    Vector3 v;

    // Start is called before the first frame update
    void Start()
    {
        v = transform.position;						//transform.positionを代入する時にコピーが渡される　同じ値だけど別物
    }
    // Update is called once per frame
    void Update()
    {
        v += Vector3.right;							//Transformとは無関係なのでキューブは動かない
    }

}
=====================

＜参照型＞
実体が１つ　ー　1回の作成　１つ分のメモリ消費　実データが存在しないのでアクセスしに行く時間が発生する　アクセスしなきゃメモリは食わない

＜値型＞
１つ１つで、実データ作成　アクセス時間が短い　ただし何度もコピーするのであれば参照型の方が処理が早くなる

軽いデータは値型の方が早く　それ以外は参照型の方が早い

データを変更した時　↓ありがちなミス　メソッドでのデータ受け渡し時は注意
値型で元データに反映されていない
参照型で元データを変えてしまった

何が値型で何が参照型か
＜値型＞
int
float
double
char
bool
構造体 struct　クラスと似ている　クラスとの違いは値型か参照型かの違い　クラスclass(設計図)→実体インスタンス(transform)　構造体struct(設計図)→実体インスタンス(Vector3)
値型もどき　string  ほんとは参照型だが挙動は値型と同じ
＜参照型＞
class
配列　←値型の配列でも配列自体は参照型

クラスと構造体の見分け方
transformとエディタで書いた時クラスはclassと表示される
Vector3はstructと表示される


＃25スクリプトの構造を知ろう
・名前空間
・メンバ

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
＜名前空間＞
フォルダみたいなもの
↑
using ○○;でフォルダの中に入っている機能を使える
namespace 好きな名前
{
	//クラスなどを書く　←名前空間の中にある機能
}

namespace FolderA
{
	namespace FolderB
	{
		//クラスなどを書く
	}
}
↓こう書いてもよい
namespace FolderA.FolderB
{
	//クラスなどを書く
}
＿＿＿＿＿＿＿＿＿＿＿＿
｜※名前空間 FolderA　｜
｜＿＿＿＿＿＿＿＿＿＿ ｜
｜｜名前空間 FolderB｜｜
｜｜class A		 ｜｜
｜｜＿＿＿＿＿＿＿＿ ｜｜
｜＿＿＿＿＿＿＿＿＿＿ ｜

名前空間内にアクセス
Aはクラス名　今はBのクラスに記載
void Start()
{
	FolderA.FolderB.A a = GetComponent<FloderA.FolderB.A>();


using FoderA.FolderB;			←これを書くことで（階層を全部書く）

void Start()
{
	A a = GetComponent<A>();　←名前空間を書かなくても使える
}

名前空間を書くメリットは？
メリット１　名前が被ってもいい　存在する名前空間が違うと同じ名前でもOK　クラスA　クラスA
プレイヤー攻撃クラス			敵攻撃クラス			区別が必要なので名前が長くなりやすい
PlayerAttackLaser			EnemyAttackLaser
PlayerAttackBomb			EnemyAttackBomb
PlayerAttackHomingMissile	EnemyAttackHomingMissile
	　　・						・
	　　・						・
	　　・						・
＿＿＿＿＿＿＿＿＿＿＿＿　	＿＿＿＿＿＿＿＿＿＿＿＿
｜Player                     　｜	｜Enemy            	     ｜		
｜＿＿＿ ＿＿＿＿＿＿＿ ｜		｜＿＿＿＿＿＿＿＿＿＿  ｜		
｜｜Attack                 ｜｜		｜｜Attack                 ｜｜		
｜｜Laser  		 ｜｜		｜｜Laser  		 ｜｜		
｜｜Bomb  		 ｜｜		｜｜Bomb  		 ｜｜		
｜｜HomingMissile  	 ｜｜		｜｜HomingMissile  	 ｜｜		
｜｜＿＿＿＿＿＿＿＿ ｜｜		｜｜＿＿＿＿＿＿＿＿ ｜｜		
｜＿＿＿＿＿＿＿＿＿＿ ｜		｜＿＿＿＿＿＿＿＿＿＿ ｜		
　　
長い名前を防止できる　ミスを減らせる
他の人との名前衝突を避ける
＜メリット２＞クラス名を覚えなくてもいい　　名前空間.で中身の一覧が見れる　チーム開発で他の人が把握するのに便利　他の人が名前空間から機能を把握しやすい

＜名前空間内に書ける型＞
クラス
構造体

namespace FolderA
{
	public class A
	{
	}

	public struct B 構造体も書ける
	{
	}
}
名前空間を書かない場合　自動的にglobal namespaceに入れられる

＜クラスや構造体の中に書けるもの＞
メンバ

クラスや構造体の中に書ける型
クラスや構造体の中に定義できる変数をフィールドもしくはメンバ変数という

namespace FolderA
{
	public class A
	{
		int a; //フィールド（メンバ変数）

		void B() //メンバメソッド
		{

		}

		class C //入れ子にされた型（内部クラス）
		{

		}

		struct D //入れ子にされた型
		{	

		}
	}

	public class B
	{

	}
}


#26 アクセス修飾子
公開範囲
シリアライズ化
public class   アクセス修飾子
＜アクセス修飾子＞アクセスできるものを指定する

AとBのスクリプト
Aのスクリプト
=====================
public class A : MonoBehaviour
{
   	 // Start is called before the first frame update
    	void Start()
    	{
        
    	}
    	// Update is called once per frame
    	void Update()
    	{

    	}

	public void Test()		//追加   //publicを追加
	{

	}
}
=====================
Bのスクリプト
=====================
public class B : MonoBehaviour
{
   	 // Start is called before the first frame update
    	void Start()
    	{
        		A a = GetComponent<A>();	
		a.Test();					//アクセスできない　//アクセス可能
    	}
    	// Update is called once per frame
    	private void Update()			//メソッドにも書くことができる これもデフォルトはprivate
    	{

    	}
}

internal struct test4				//メンバではない型はpublicかinternalしか書くことができない
{
								//MonoBehaviourを継承しているとpublicしか書けない
}
struct test4						//何も書いてないとinternalと同じ
{

}

=====================
アクセスしたい場合はアクセス修飾子を使ってアクセスできるようにしよう
<アクセス修飾子>他スクリプトからのアクセスをコントロールできる

＜アクセス修飾子の種類＞ 型やメソッドのメンバにつけられる
private			その型をメンバに含んでいる場合にのみアクセス可能		←それ以外			private int a = 0;
public			どこからでもアクセス可能							←アクセスしたい時	public int b = 0;
protected			その型を継承した型のみアクセス可能									protected int c = 0;
internal			同じアセンブリの型からのみアクセス可能								internal int d = 0;
protected internal	同じアセンブリに書かれてかつその型を継承した型からのみアクセス可能		protected internal int e =0;

型やメソッドの修飾子を付けないとprivateと同じ扱い  なにも書いてない状態だとアクセスできない
int f = 0;

namespace Test //名前空間にはアクセス修飾子はつけられないが挙動はpublicと同じ

シリアライズ化とは　ソフトウェア内部で扱っているデータをそのまま、保存したり送受信することが出来るように変換すること
＜publicな変数＞
unityでシリアライズ化される場合がある


=====================

public class test : MonoBehaviour
    {
        private int a = 0;
        public int b = 0;
        protected int c = 0;
        internal int d = 0;
        protected internal int e = 0;

        int f = 0; //privateと同じ

        // Start is called before the first frame update
        void Start()
        {

        }
        // Update is called once per frame
        void Update()
        {
	Debug.Log(b);
        }

    }
=====================
public int bだけがインスペクターに表示される　unityの仕様でBと表示される
スクリプトを変更しなくても値を追加できる　インスペクターで編集できる　スクリプトとインスペクターの値が反映される 

シリアライズ化できる型
public class test : MonoBehaviour
{
	public int a;
}
できる↓
public int [] c; ←シリアライズ可能な型の配列も可能
public float
public double
public char
public string
public bool
public A d; ←MonoBehaviourを継承した型
public GameObject e; ←ゲームオブジェクト
public Transform f;　←コンポーネント

できない↓
構造体　
public Vector3 b; 基本的にはできないがUnityが定義したものは可能なものがある　自分が定義したものは工夫しないとできない
public test4 g; MonoBehaviourを継承していないクラス ※一部例外有り
=====================

public class test : MonoBehaviour
{
    public int a;				//シリアライズ化された型はインスペクターに表示される
    public Vector3 b;
    public int[] c;			//配列[]は要素数を入れてあげる
    public A d;
    public GameObject e;		//ヒイラルキーからドラッグアンドドロップ可能　インスタンスの参照を初期値として持てる
    public Transform f;		//ヒイラルキーからドラッグアンドドロップ可能

    public test g;
=====================

＜まとめ＞
他のスクリプトからアクセスしたい
インスペクターから値を調整したい
↑
publicを使おう　ただしpublicにするのは必要最低限にしよう　混乱するから


＃27　UIを作ってみよう
・絵の表示
・テキストの表示
・ボタン作成
UIとはユーザーインターフェース　UIを便利に作れる機能　UGUIを使う
ヒエラルキー右クリック→UI→キャンバスグループ＝Canvas & EventSystem
Canvas ←UGUIを表示させるために必要　UGUIを子オブジェクトにして使う　画面は可変する
UGUIとはUI配下に陳列されているものキャンバスグループもUGUIの一つ　UGUIを使用するにやキャンバスが必要
EventSystemとは画面上で起きたイベントをUGUIに伝える役割
白い□がキャンバスの枠　ゲームビューの大きさを変えると白枠の大きさも変わる
Canvasとはゲーム画面に合わせてUIの大きさを調整してくれる機能

絵を表示してみよう
Pixelmatorで適当な絵を書く　a.pngで書き出し　unity006に保存　unityのプロジェクトへドロップ
インスペクター　テクスチャタイプをスプライト（2D and UI）に変更　適用する
Spriteは２Dグラフィックオブジェクト
UGUIの画像を選択　■が出現　Canvasの下のImageを選択　
Imageのソース画像にa.pngをドロップ
位置、幅、高さを変更できる　Image をCanvasの子オブジェクトから外すと使えなくなる

テキストを表示してみよう
UGUIのテキストを選択　Textを選択した状態でインスペクターでテキストを編集できる

ボタンを作成してみよう
UGUIのXボタンを押下　見た目はImageとTextから出来ている
=====================

void Update()
        {
        }
        public void TestClick()
        {
            Debug.Log("ボタンを押した");
        }
    }
=====================
上の記載　Buttonのコンポーネントを追加にスクリプトをドロップ
ボタンのインスペクターにクリック時（）　リストは空です　＋−が出現　＋を押下
オブジェクトを入れる項目が出現　ヒエラルキーのボタンをオブジェクトへドロップ
No Functionをtest（作成したスクリプト）.TestClick（作成したメソッド）を選択
シーンを再生して▶ゲーム画面からボタンを押すとログにボタンを押したと表示される
ボタンからメソッドを呼び出せる

＃28　プレハブを使ってみよう
オブジェクトの複製方法
アセッツ右クリック作成　マテリアル
command + Dで複製可能　ヒエラルキー右クリック　複製でも可能
＜プレハブとは＞元ファイルのようなもの　元ファイルから複製を作成　元ファイル↔複製物　リンクしている

ヒエラルキーのCubeをプロジェクトウィンドウにドラッグアンドドロップ（アセッツAssets等）プレハブが作成される
プロジェクトウィンドウからシーンビューにドラッグアンドドロップすると複製される
プレハブとリンクするオブジェクトは青色になる

プレハブモードを使おう
オブジェクトのプレハブを選択　プレハブを開く　プレハブモードになる（元ファイルを編集するモード）
編集後　シーンか＜で反映される
Cube右クリック→プレハブ→展開　もしくは　すべてを展開でプレハブが解除される

ゲームオブジェクト側の変更
プレハブの一つを変更すると変更した箇所が青い縦線がつく｜
独自の変更がある場合　プレハブの影響を受けなくなる　変更が適用されないのは独自に変更したパラメータのみ
一番親の位置と回転は独自の変更として扱われない

独自変更をプレハブに適用しよう
独自に変更したプレハブを選び　インスペクターのオーバーライド🔽クリックすると独自の変更一覧が表示される
ここで　すべてもとに戻す（元のプレハブと同じに戻る）とすべて適用するを押すと
すべてのプレハブに独自の変更が適用される


＃29　プレハブの入れ子と派生
プレハブの親子関係について
Nested Prefabs
Prefab Variants

キューブ作成　子スフィア作成　キューブをプレハブにする　スフィア（Sphere）の文字だけが青くなる
プレハブは子オブジェクトを含むことが出来る
新たにカプセルを作成しキューブに入れようとするとエラーとなる（プレハブインスタンスの子は削除、移動ができない）
＜プレハブの親子関係＞独自の変更を持つことが出来ない←そんなわけないんですよね
スフィアの下にドロップすると＋カプセルとなる（プラスマークがつく）変更を加えたから
キューブ　インスペクター　オーバーライド　すべて適用する　でプレハブに追加できる　カプセル
キューブを追加　キューブ右クリック　Added GameObject プレハブキューブ１に適用でプレハブに含めることができる　個別に変更を適用できる
キューブ１　インスペクター　コンポーネントを追加　ri  Rigidbody 追加したリジッドボディ（コンポーネント）にも＋が付き青い線が付く
こちらも・・・Added GameObject プレハブキューブ１に適用で個別に適用できる
パラメータの変更もパラメータを変更した後・・・Modified Component プレハブキューブ１に適用で適用できる
Box Colliderも同様に出来る
＜プレハブ内の子オブジェクト＞順移動、解除、削除は独自変更できない　プレハブモードにすると変更できる
＜プレハブ内の子オブジェクト＞全てのプレハブに変更を適用するしかない　親子関係に注意！

Nested Prefabs　ネステッドプレハブ
シリンダーを作成　プロジェクトにドロップ　■キューブと■シリンダー別々のプレハブができる
シリンダーを＋にする
キューブ　インスペクター　オーバーライド　すべてを適用する　→プレハブの中にプレハブを含めることができる
🔽■Cube	<Nested Prefabs>プレハブの中にプレハブがあるプレハブ　ネステッドプレハブ
	■Sphere
	■Capsule
	■Cylinder  プレハブモードで編集すると変更される
同じプレハブ↓は適用できない

	
＋Cubeは２種類のプレハブにぞくしているので　＋Cube右クリック→Added GameObject→Cube適用かCylinder適用を選べる

どのプレハブに適用するか選べる　オーバーライドからも適用できる

Prefab Variant プレハブバリアント
プレハブの派生
プレハブを作り、同じようにドロップするとプレハブバリアントにするか聞かれる
元々変更→　○　→派生
派生変更→　✗　→元々
ドロップすると元々のプレハブがヒエラルキーから消えるのでプロジェクトからドロップする（元を使いたければ）
プロジェクトのプレハブ右クリック→作成→プレハブバリアントでも作成できる
派生同士に直接の繋がりはない
派生したものに元（ベース）を変更したい場合はプロジェクトの派生を選択→プレハブを開く→オーバーライド→すべてをベースに適用
ただし個別に変更した同じ種類の変更は適用されない
いくつでも派生可能
プレハブバリアントはベースのプレハブとNestedな状態にすることができない

Unpack Prefab Completely アンパックプレハブ　コンプリートリイ
ヒエラルキープレハブ右クリック→プレハブ→展開（プレハブ解除）すべてを展開（子オブジェクトも含みプレハブ解除）　


#３０ Unityのちょっとした注意点
再生中▶に変更したものでも元に戻らないものもある →バージョンUPで解決済み
<シリアライズ化された値>インスペクターの変更よりスクリプトの変更が優先される

インスペクターで値を変更できる
=====================

public class test : MonoBehaviour
{
        public int a = 1;

        // Start is called before the first frame update
        void Start()
        {

        }
        // Update is called once per frame
        void Update()
        {
        a = 1;		//値を指定するとインスペクターで変更不可となる
        Debug.Log(a);
        }
    }
=====================
インスペクターで変更できないモノは何かの処理で値を変更されている
値だけでなく、様々なモノが動かせない場合、何かに変更を加えられている
インスペクターの変数に初期値を入れる意味　public int a = 1;	貼り付けた時　最初から値が入るので便利
セーブ
ファイル→プロジェクトを保存はシーンは保存されない
ファイル→保存　セーブプロジェクトの内容も含めてセーブ


#３２　デバッグのやり方
不具合の原因を突き止める方法
エラーを確認しよう　コンソール❗エラー　無視してもいいエラーもある　エラーを選択するとエラーの詳細がでてくる　これをドラックコピー翻訳検索　エラー何？把握
無視しても大丈夫なエラーは無視しても大丈夫という検索結果がでる
エラーログをダブルクリックでエラー箇所が開く　開かない場合はエラーのファイル名の何行目〜何行目かを確認する（14,10）:error
ファイル名が無い場合（Assets\test.cs）システム的エラーか何かの処理をした際のエラーの可能性がある
コンソールの消去を押下しても消えない場合
・プログラムが間違っている　・入れられないファイルがある
消える場合
・タイミングで起きるエラー
プログラム（コード）が間違っている場合、ビジュアルスタジオのエラー一覧を見たら原因が大体解る

状況を把握しよう
・どのタイミングでエラーになっているかわからない　・エラーにはなってないが思った動きになっていない　・どういった処理になっているかよくわからない
調べればOK
Debug.Logを使おう
＜ログが表示されない場合＞
・セーブし忘れ　・スクリプト貼り忘れ　・スクリプトが有効ではない　・メソッド名が違う　・ログがオフになっている
void Starta()
{
	Debug.Log(“確認”);
}
凡ミスじゃないなら処理を通ってない

↓確認は表示された　ボタン押した表示されない場合
Debug.Log(“確認”);
if(ボタンを押したら)	←false
{
	Debug.Log(“ボタン押した”);
}
考えられる原因
毎フレームではない場合、フレーム内にボタンを押さないといけない
ボタンを押したらという条件がうまく機能していない　←条件を調べよう
Debug.Log(“確認”);
if(Input. GetKey (KeyCode. Space)) //スペースキー押すと○押さないfalse
{
	Debug.Log(“ボタン押した”);
}
上手く行かない場合　調査あるのみ　[Input GetKey 動かない]Google
決めつけはミスの元　どこが原因かを明確にする
デバックログは通ったか通ってないかの確認だけではなく変数の中身をみることができる

NullReferenceException: Object reference not set to an instance of an object
kaeru.Start () (at Assets/kaeru.cs:18)
↑何かよくわからないエラー
=====================

void Start()
    {
        Vector3 v = new Vector3();
        v.x = 3;
        v.y = 1;
        v.z = 2;

        GameObject g = GameObject.Find("Enemy");	//原因はコレ　GameObjectを取得できていない
        Debug.Log(g);					//そこで使っている変数やメソッドなど原因になりうるもの全てをログに出力しまくる　	//Null
        Debug.Log(v);																					//(3.0, 1.0, 2.0)Vector3の値
        Debug.Log(g.transform);			//Nullにアクセス													//謎のエラー
        Debug.Log(g.transform.position);
        g.transform.position = v;			//この行のエラーは解るが何がエラーかわからない
    }
=====================
Debug.Logで原因を突き止めよう

シリアライズ化を使おう
調査方法はDebug.Logだけじゃない

=====================

public class kaeru : MonoBehaviour
{
    int a;

    // Start is called before the first frame update
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        ++a;				//どう変化しているか知りたい場合
        Debug.Log(a);
    }
}
=====================
ログが流れてしまってよくわからない…　

２
３
４
…
変数をシリアライズ化してしまう
=====================

public class kaeru : MonoBehaviour
{
    public int a;

    // Start is called before the first frame update
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        ++a;
    }
}
=====================

値の変化をインスペクターで見ることが出来る	123456789…
随時変化していくものを調査したい場合　便利　
元々変数でないものを調査したい場合でもデバック用の変数を作ってその中に入れて調査する方法もある

ブレークポイントを張ろう
=====================

public class kaeru : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        int a = 1;					//①変数　aを定義

        if(a ==1)					//②if文で条件判定			//aを10に変更　if文がfalseとなり
        {
            Debug.Log("ifの中に入った");
            a = 2;					//③aの数値を２にする
            a = Test();				//④メソッドからの返り値を返す
            a = 4;					//⑥aの数値を４にする
        }
        Debug.Log(a);										//10を表示
    } 

    // Update is called once per frame
    void Update()
    {
     
    }

    int Test()
    {
        return 3;					//⑤３を返しているだけ
    }
}
=====================
↑単に値を増やしていくだけのスクリプト

ビジュアルスタジオの▶を押す（デバッグモード）Unityとビジュアルスタジオが連携する
左側をクリックすると◎が付く

この状態でUnityを実行すると▶

↑処理がここで止まる　処理を中断して、その瞬間の状況を調べることが出来る

↑カーソルを合わせると変数の中身を見ることが出来る

↑現在取り扱っている変数とその値が表示されている

↑クリックすることで値が変更できる

↑10に変更した状態でビジュアルスタジオ▶を押すとログに表示される
if(a ==1)で処理が止まっている間にaを１０に変更した

処理途中の状況把握　値を指定したテストが可能
処理が止まっている間はUnityを触ることが出来ない　ビジュアルスタジオの停止ボタン■で解除できる
◎は何個も付けることができるビジュアルスタジオの▶で次の◎に以降する

↑ステップオーバーで処理を一行ずつ実行することが出来る　メソッド内は処理を追わない　メソッド中では停止せずに次に進む

↑ステップインで処理を中断したところから一行ずつ実行することが出来る　メソッドに入った時そのメソッドにおって順に進んでいく　メソッド内の処理が終われば返る

↑ステップアウト　メソッド内からメソッドの呼び出し元まで戻ることができる

Debug.Log、シリアライズ化、ブレークポイント使い分けよう

その他確認すべきこと
同じスクリプトが複数ついている　←外す
シリアライズ化されていたスクリプトがMissing(参照が外れた)　←付け直せ
スクリプト自体の参照が外れた　The associated script can not be loaded. 　←対象のスクリプトをもう一回貼り付ける　もしくはエラーを直す
スクリプトを貼り付けた際　Can’t add script component ぶらぶらぶら…　スクリプトのクラス名とファイル名が違う　←クラス名とファイル名を揃える
物体がピンク色になった場合　シェーダーエラー　シェーダープログラムを直すのは難しい　←別のシェーダーを使う
Unity自体がフリーズしてしまったら
ブレークポイントを貼っていないか
重い処理中か　←待つ
無限ループではないか
Unity自体がおかしい場合　

↑コンソールウィンドウの右上からエディターログを開くでUnity自体のログを見ることが出来る（できてない）


#３２　作り始める前にやるべきこと
Step1 プラットフォームを切り替えよう
プラットフォームの設定切り替え　ファイルの変換処理が入るので一番最初にやってしまうと吉
ファイル→ビルド設定

モジュールの追加は　#６を参照
プラットフォームによっては契約が必要なものがある　SP4など　モジュール追加にもない場合企業の案内を確認
プラットフォームの一覧にあったとしてもNo module loadedの場合はモジュールの追加が必要
変更したいプラットフォームを選択しSwitch Platformを選択→変換処理（プラットフォームの切り替わりが走る）
Unityアイコンが完了の証

Step2 解像度とアスペクト比を考えよう
＜ゲームでの解像度＞画面のピクセル数（画面解像度）
幅と高さのピクセル数□←比率をアスペクト比
ディスプレイの解像度　プレイヤー次第で異なる場合がある　機種によって違う　最初に考えないと、はみ出る物を再配置しないといけなくなる
画面設計
１６：９　４：３　２；１
＜どう対策するのか＞
UI部分の調整　ゲーム部分のアスペクト比　画面全体の解像度
＜UI部分の調整＞
４：３　縮小→□←　↑位置調整　|Stage3 			Score 10|
拡大縮小の設定・・・Canvas
位置調整・・・個別に調整可能
＜UIの調整＞
設定すればUnityが調整してくれる
＜ゲーム部分のアスペクト比＞
ゲームによって変わる
調整しない　←画面を広くとれる
帯を入れて調整〓（画面の比率を調整）
＜何故アスペクト比を調整するのか？＞
余白があるとビジュアルに違和感がある
余白が必要
見えたり見えなかったりするのでゲーム中で使う物を入れられない　余白部分はゲーム中必須ではないものを表示することとなる
余白で画面に違和感　見せたくないものを画面外に置きづらい
ディスプレイによって有利・不利が発生する←　２Dアクションでは非常に重要
横スクロールアクションの場合　横有利　縦不利　ゲーム外で有利、不利が発生するのはよくない
２Dアクションは縦・横共に有利不利が発生する場合が多い　余白を持たせないためにアスペクト比を固定する場合が多い　アスペクト比固定で進める　←固定じゃなくても良い
アスペクト比を固定する以外の方法もあるが初心者向けではない
＜アスペクト比を固定する方法＞
自分でアスペクト比を決めることが出来る　やる事　アスペクト比を決めよう　分からない人は真ん中ぐらいのアスペクト比を選択すればOK
４：３		iPad					4/3		1.333333333333333
１６：９		iPhone（5c 〜　8plus)	16/9		1.777777777777778
１９．５：９	iPhone（X 〜 １１）		19.5/9	2.166666666666667
2:3								3/2		1.5
40:71							71/40	1.775						
139:199							199/139	1.431654676258993

４：３		iPad					4/3		1.333333333333333	▲正方形より
139:199							199/139	1.431654676258993	
2:3								3/2		1.5					真ん中くらいでいいが　１６：９が無難
40:71							71/40	1.775				
１６：９		iPhone（5c 〜　8plus)	16/9		1.777777777777778	
１９．５：９	iPhone（X 〜 １１）		19.5/9	2.166666666666667	▼横に長い

＜画面全体の解像度について＞
最近のディスプレイは高解像度過ぎる！　重すぎてカクカクになる！　GPUがついてこれない　←解像度の上限値を決めて超えるなら下げる必要がある
やること　解像度の上限値を決めよう　上限値がどんな値がいいのかは状況や時代によって変わる　分からない人は９６０ぐらいが無難
縦横の解像度を計算しよう
最大解像度÷アスペクト比の大きい方の数値×アスペクト比の小さい方の数値
＜無難な場合の例＞
９６０÷１６×９＝５４０
アスペクト比	１６：９
解像度		９６０×５４０
＜解像度とアスペクト比のプログラム＞
現段階では難しいので応急処置をとる
ゲームビュー下のFree Aspectをクリック→　＋　↓		

ラベル名を入力し解像度を入力しOK　Unityで見るゲームビューが固定される　擬似的にアスペクト比と解像度を固定することが出来た
ゲームオブジェクト位置を後で調整するというミスを避けることが出来る　擬似的でも固定されていればゲーム制作中は問題ない
完了　アスペクト比の決定　最大解像度の決定
ToDo  UI部分の調整　アスペクト比の固定　解像度を下げる　←ブラウザゲームはこれで完了　やる必要がない　解像度を自分で指定できるので調整がいらない


＃３３　タイトルシールを作成しよう
Step3 タイトルを一枚絵で表現しよう
シーンの作り方は無限大だが　一枚絵でタイトルシーン作成　非常に簡単な作り方　初期シーンが軽くなる
デフォルトのシーンはSAMPLEシーンになっているので新しくシーンを作成する
ファイル→新しいシーン　ファイル→別名で保存
/Users/me-do/Desktop/unity/006/006/Assets/Scenes/titleScenes.unity
やること　Canvasの設定
ヒエラルキー右クリックUI→キャンバスグループ（ヒエラルキーにCanvas とEventSystemが作成される）
ヒエラルキーのCanvasを選択した状態でインスペクターのCanvasレンダーモードをスクリーンスペースーカメラに変更する
キャンバスのレンダーモードはUIを表示する空間の設定　全面表示→カメラに変更　後々調整がやりやすくなる
表示されるパラメータが変わってレンダーカメラが出現　ここにMain Cameraをドラッグアンドドロップ　UIがメインカメラに映るようになる
インスペクターのCanvas Scaler
Canvas ScalerとはCanvas配下のUIの大きさを調整するコンポーネント
UIスケールモードを画面サイズに拡大に変更　UI Scale Mode 大きさを変更する基準　ピクセル数→画面の大きさ
参照解像度をX９６０　Y５４０に変更　画面の解像度から計算して拡大縮小するようになる
スクリーンマッチモード　Screen Match Mode どのように拡大縮小するのかという設定　Match Width Or Height デフォルト　画面の横側に合わせる
マッチで画面の幅か高さに合わせるかを設定できるがアスペクト比固定する場合　後でスクリプトで変更をかけるので　今はどちらでも構わない
完了　Canvasの設定
ToDo カメラのアスペクト比　←どんな絵にも対応するため　固定する
やること　絵の配置
Image作成　ヒエラルキーCanvasを選択した状態で右クリックUI→画像
インスペクターのRect Transform UGUI版トランスフォーム　
UGUIの位置、回転、拡大縮小、幅高さ、UIのどの位置を中心にするのか（中心位置）、どこを基準にして配置するのか（基準位置）		
幅と高さを画面に合わせるWidth幅９６０Height高さ５４０		

Pixelmatorを開く

下書きを作成
＜何故下書きを推奨するのか＞
ゲームの根幹部分の作成やわからないところをやってみる　仕様を一部分だけ持ってきても食い合わせが悪い場合がある

他人の仕様を試しもせずに突っ込むと痛い目を見ます　やったことない　分からない事は試しに作ってみよう　ここでグラフィックを完璧にする必要はない
モック	２０％	試しに作ってみる		シーン１	シーン２	シーン３
α版		４０％	ある程度形にする		シーン１	シーン２	シーン３	グラフィックを差し替えていく
β版		８０％	完成に近づける			シーン１	シーン２	シーン３　シーン４　シーン５　ある程度やり方が解っている　追加のシーンを作成していく
Fix版		９０％	調整・ブラッシュアップ	シーン１	シーン２	シーン３　シーン４　シーン５　全体をよく見る
Fix版		１００％	デバッグ				シーン１	シーン２	シーン３　シーン４　シーン５　完成
作り方は人それぞれだけど分からない間はモックから入ろう
titleBackGround.pngで保存(日本語にしない！　時々へんなバクになる)
/Users/me-do/Desktop/unity/006/titleBackGround.png

プロジェクトウィンドウ右クリック作成→フォルダ  　フォルダ名をTextureに変更　整理整頓の意味もあるが後で作業を一気に終わらす為
特殊な方法を使うと上書きでTextureに差し替えられる　下書きから本番用に変更時　再配置する必要がなくなる
プロジェクトのTexture配下にtitleBackGround.pngをドラッグアンドドロップ
titleBackGround.pngを選択した状態でインスペクターのテクスチャタイプをスプライトに変更
ヒエラルキーImageを選択→適応→インスペクターImage ソース画像にtitleBackGround.pngをドラッグアンドドロップ

Step4　テキストを使いこなそう
やること　タイトル文字をテキストで作成
ヒエラルキーCanbasを選択右クリックUI→テキスト
ヒエラルキーテキストを選択　インスペクターParagraph水面オーバーフローをOverflow　垂直オーバーフローをOverflow
テキストを　タイトルにして画面の中心にもってくる（フォントサイズ８３　白　整列　真ん中）※90に変更

TextがImageの下にくるようにする　下にある方が全面表示
＜Textの注意点＞
文字の大きさに注意
Textインスペクター　拡大/縮小 X Y Z　と　フォントサイズ　で修正する２つのパターンが存在する　どちらを使えば？　ScaleとFont Size両方使用する　
文字はテクスチャ　Scaleは単なる拡大縮小　小さいテクスチャ（絵）を引き伸ばしたらボケる
Font Sizeが１でも違うと別物の文字がテクスチャに生成される　フォントサイズがバラバラな文字を使うとメモリをバカ食いする　ロール時間遅い　クラッシュの原因となる
フォントサイズを全て一緒にしたら？　←小さいフォントサイズだけだと文字がボケる　大きいフォントサイズだけだとメモリをバカ食いする
・大きいフォントサイズ	→拡大		90
					→縮小
・中位フォントサイズ		→拡大		60
					→縮小
・小さいフォントサイズ	→拡大		30
					→縮小
↑ある程度メモリにやさしく運用できる
テキストを置いたら、使ったフォントサイズをメモしておこう
近いフォントサイズを使用してスケールで大きさを調整する

Step5 スタートボタンを設置しよう
ヒエラルキーCanvasを選択した状態で右クリックUI→X ボタン
シーンを２D表示にする　
ヒエラルキーButtonを選択した状態でインスペクターRect Transform　位置Y-176　幅200　高さ60

↑ボタンの下のテキストもフォントサイズ　26メモする　文字はStart　※30に変更

プロジェクトのアセッツ配下にScriptフォルダを作成　プロジェクトAssets選択右クリックー作成ーフォルダ　名前をScript
プロジェクトのスクリプト配下にスクリプトを配置　名前Title  Scriptフォルダ右クリックー作成ーC＃　スクリプト　名前をTitle
スクリプトをダブルクリックでバーチャルスタジオを立ち上げる　public class Titleに修正する
=====================
public class Title : MonoBehaviour
{
    //スタートボタンを押されたら呼ばれる
    public void PressStart()
    {
        Debug.Log("Press Start!");
    }
}
=====================
↑スクリプトをアタッチ　ヒエラルキーCanvasを選択　インスペクターのコンポーネントを追加にスクリプトをドラッグアンドドロップ
ヒエラルキーButtonを選択　インスペクター　クリック時（）の＋を押下　オブジェクトにCanvasをドラッグアンドドロップ
No FunctionをTitle-PressStartに変更
Unity実行▶　ゲーム画面のボタンを押す　ログにPress Start!と表示される
このままでは連打されると命令が何度も呼び出されてしまう！　連打対策をしよう！
=====================
public class Title : MonoBehaviour
{
    private bool firstPush = false;

    //スタートボタンを押されたら呼ばれる
    public void PressStart()
    {
        Debug.Log("Press Start!");

        if (!firstPush)				//falseじゃないと通らない
        { 
	    Debug.Log("Go Next Scene!");	//ログを仕込んで動作確認
            //ここに次のシーンへ行く命令を書く
            //
            firstPush = true;			//trueにするので一度しか通らない
        }
    }
}
=====================
Press Start!はボタンを押されるたびにログが出るがGo Next Scene!は一度しかログにでない
完了　タイトルシーンの土台完成
ToDo　次のシーンへの遷移　グラフィックの差し替え


#３４　アニメーションを作ってみよう
Step6  キャラクターを作ろう
やること　キャラクターの下書きを作る　使用するお絵かきソフトは背景を透明にできるソフトを使用（GIMP,FireAlpaca等）
＜画像の大きさ＞
幅、高さを２のべき乗にしよう！
＜なぜ２のべき乗にするのか＞
圧縮ができないから→重くなる
２のべき乗　１，２，４，８，１６，３２，６４，１２８，２５６，５１２，１０２４，２０４８，４０９６
小さいサイズから徐々に大きくして試してみよう　←大きいと重くなる為　ロード時間が長くなる
画像の綺麗さと大きさのバランスがいいところを探そう　幅１２８　高さ２５６　と　３００×１５０
iOSは正方形でないと圧縮できない　iOSが使う圧縮形式が正方形じゃないと出来ない　変な余白ができたとしても正方形にする　２５６　２５６
やること　動きの種類を決めよう
＜作成する動き＞
・立ち
・走り
・ジャンプ（上昇・下降）
・クリア（クリア時のモーション）
・ダウン（やられた時のモーション）
↑パラパラ漫画のように描いてみる
幅２５６　高２５６　解像度９６０

↑titleScenesの左横の目を押すとタイトルシーン画面が消える

右クリック新規シーンを追加でUntitledを追加する

地面につくなら足を枠の一番下まで書く
可能な限り絵の大きさは同じに
枠の大きさが違う場合は中心を意識する
他の画像と中心が合わない場合Unity側で調整できる
テクスチャタイプTexture TypeをスプライトSprite(2D and UI)に変更しピボットPivotをカスタムCustom  X Y で調整　中心を値で指定(0,0)左下（1,1）右上
中心の調整を個々にするのは大変なのでなるべく画像側で揃えよう

以下をiPadのProcreate＋アップルペンシルを使って作成する
背景なしのPNG画像の名前は頭に使用用途を書くと便利
player_down1
player_down2
player_down3
player_jump_down
player_jump_up
player_run1
player_run2
player_run3
player_stand
player_win
作成したpngを　/Users/me-do/Desktop/unity/006/に保存
↑をUnityのプロジェクトTextureにドラッグアンドドロップ

↑プロジェクトウィンドウの右上アイコンからTextureを選択  ←テクスチャのみを表示
さらに名前検索することで目的のファイルのみ表示↓
🔍t:Texture player
↑これらをシフトを押しながら全選択　テクスチャタイプをスプライト　iOS用に上書き　適用する
やること
アニメーションの作成
player_standをヒエラルキーにドラッグアンドドロップ

↑シーンにかえるちゃんが出現
ヒエラルキーのplayer_standを選択した状態でインスペクターのコンポーネントを追加を押下　animatorを検索してアニメーター押下
アニメーション用のフォルダ作成 プロジェクトAssets配下で右クリック作成ーフォルダ　フォルダ名Animation
Animation配下で右クリックCreate作成ーAnimator Controllerアニメーターコントローラーを押下 名前player_animator
ヒエラルキーplayer_standを選択した状態でplayer_animatorをインスペクターAnimatorのControllerコントローラーへドラッグアンドドロップ
これでキャラクターにアニメーションを付ける下準備ができた
Unity上のタブ　ウィンドウーアニメーションーアニメーションを選択　アニメーションウィンドウが開く
ヒエラルキーのキャラクターplayer_standを選択した状態でアニメーションウィンドウのCreate作成を押下  ←アニメーションファイル新規作成
作成するアニメーション名で保存　player_stand.anim save

/Users/me-do/Desktop/unity/006/006/Assets/Animation/player_stand.anim
アニメーションウィンドウに時系列の表が付く

ヒエラルキーのplayer_standを選択した状態でプロジェクトのplayer_standをアニメーションウィンドウのプロパティーを追加にドラッグアンドドロップ▼押下

↑立ちモーションのアニメーション　画像１つだけバージョン
別のアニメーション作成　走る
player_stand横の▼をクリックー新しいクリップを作成…を押下　新規アニメーションが立ち上がる　アニメーション名（player_run.anim）を入力してSave

↑プロジェクトのplayer_run1〜3をアニメーションウィンドウにドラッグアンドドロップ　(0:00.run1) (0:10.run2) (0:20.run3)に配置
アニメーションウィンドウのプレビュー横▶（再生ボタン）を押下するとかえるちゃんが走る
ぎこちない走りする（最後の一コマが一瞬で終わってしまっている）ので同じ画像を(0:30.run1)に配置する　▶走っているように見えるようになる
配置する感覚を狭くするとアニメーションの速度が早くなる（0:00  0:05 0:10 0:15）
感覚を空けると走る速度が遅くなる（0:00 0:15 0:30 0:45）

↓同じようにして全部のアニメーションを作る
PNG				時間			アニメーション名
player_down1		(0:00 0:45)	player_down
player_down2		(0:15)
player_down3		(0:30)
player_jump_down	(0:00)		player_jump_down
player_jump_up	(0:00)		player_jump_up
player_run1
player_run2
player_run3
player_stand
player_win		(0:00)		player_win



＃３５　アニメーションを制御しよう
Step7  アニメーターとアニメーション
やること　ちゃんとゲームでアニメーションを使えるようにする
ウィンドウーアニメーションーアニメーターを選択　　　アニメーターウィンドウが開く
Animation 	アニメーションファイルそのもの
Animator 		Animator Controllerから前回作ったアニメーションを制御するもの

↑アニメーターとは　これの中身を表示するもの　

↑中身が表・示される　player_animatorの中身　キャラクターにアニメーターのコンポーネントがささっていてそこにアニメーターコントローラーがついているから
□四角一つ一つが前回作ったアニメーション
何も表示されていない場合はプレイヤーを選択するかアニメーションファイルをドラッグアンドドロップする
と表示
される
プロジェクトAnimation配下のplayer_downを選択した状態でインスペクターのループ時間の☑を外す　ループしたくないものは外す　ループ再生オンオフ
アニメーションファイルが乱雑に配置されているので整頓する

上３つの小さい四角は今回は無視　オレンジ色になっているものはデフォルトで再生されるアニメーション
デフォルトで再生されるアニメーションの変更はアニメーションを右クリックーレイヤーデフォルトステートとして登録するを押下
やること　アニメーションを切り替えていけるように　アニメーションの遷移を作る
立ち↔走り
player_standを右クリック遷移を作成 Make Transitionを押下　←やじるしが出現  player_runに繋げる
＜間違えた場合＞矢印をクリックしてdelete+commandキー
矢印をクリックするとアニメーション遷移をインスペクターに表示することが出来る
この設定を変更することでアニメーションからどのアニメーションに切り替わっていくのかを制御することが出来る　←やじるしの内容
やじるしインスペクターの終了時間ありHas Exit Time☑を外す  ←遷移にアニメーションが終わったらという条件を追加するもの
立ちモーションから走りモーションに移行する際にボタンを押したら即座に移行してほしい為☑を外す
☑がついていると　走りボタンを押されても　立ちモーションが終わる時間まで待機して走ることになる
やじるしインスペクターの▼Settingsをクリックすると詳細が表示される
遷移間隔Transition Duration (s)を０にする　アニメーションからアニメーションの移行期間　２つのアニメーションがブレンドしながら移行する
↑テクスチャ（２D）のアニメーションはブレンドできない  無意味　２Dだと変な間ができてしまう
↓！警告がでている　終了時間ありの☑を外した為　矢印を通る条件がなくなってしまった為

やること　矢印を通る条件を作る
アニメーターウィンドウのパラメーターParameters　→＋　→（なんのパラメーターを追加するのか）bool　→名前（run）
Trigger(Animatorの場合) オンオフを表すパラメーター　矢印を進むと自動でオフになる
＜パラメーターの使い方＞
float 	- 浮動小数　	例＞スピードが一定以上に達したらアニメーションを制御させる　ある値で条件を制御させる等
int		- 整数		例＞複数のアニメーションのパターンが存在して番号を割り振って制御したい時
bool 		- 真偽		例＞ON　OFFなどのフラグによる制御をしたい時
Trigger				例＞矢印を進むとOFFになるという仕様上　一方通行なアニメーションの遷移で使用されることが多い   
＜Trigger＞〇〇が起こったらという意味で使われることが多い
（Animatorの場合）
オンオフを表すパラメーター　矢印を進むと自動でオフになる
今回は走り立ちという２つのモーションの判定がとれればいいのでtrueの時走り、falseの時立ちにすれば上手くいく
runフラグがtrueの時走り、falseの時立ちにする
作成した↓を選択した状態でインスペクターConditionsリストは空です下の＋を押下

↑パラメーターを条件に追加することが出来る（矢印を通る条件を追加）
runのパラメーターを通る時、この矢印を通るという条件を追加することが出来た
＋−でさらに条件を追加したり削除することが出来る　ーボタンはrun左側の=を押す(パラメーターを選択)ことで選択して削除することが出来る
run横の▼を押下で、どのパラメーターを使うか選択することが出来る　その右側に表示されるもの(true)はパラメーターの種類によって変わる
Triggerは自動でOFFになる都合上　条件としてはONの時だけになるので右側には何も表示されない

逆側もやっていく
player_run右クリックー遷移を作成ーplayer_standに繋げる
↑を選択した状態で終了時間☑を外す　遷移間隔を０に
Conditions＋	run	▼falseを追加

↓true	↑false	runフラグがtrueの時、走るようになり、falseの時、立ち状態になるように出来た
後はこのフラグをボタンを入力した時、切り替えてあげればアニメーションを制御できる
やること　スクリプトからキー入力を受け取ってボタンが押されたらrunフラグを切り替えるようにしていく
キャラクター制御用のプログラムを作成していく
プロジェクトAssets-Script配下で右クリックー作成ーC#　スクリプト　名前Player

=====================
public class Player : MonoBehaviour
{
    private Animator anim = null;

    // Start is called before the first frame update
    void Start()
    {
        anim = GetComponent<Animator>();
    }

    // Update is called once per frame
    void Update()
    {
        float horizontalKey = Input.GetAxis("");
    }
}
=====================
Input.GetAxis()　　←Unityの入力を受け取る機能　入力の方向軸を受け取る
＜キー・ボタン入力判定の種類＞
たくさん種類がある
GetKey,GetKeyDown,GetKeyUp
GetButton,GetButtonUp,
GetButtonDown,GetAxis,GetAxisRaw
GetMouseButton,GetMouseButtonUp,
GetMouseButtonDown,GetTouch
anyKey,anyKeyDownなど
たくさん種類がある中から何故GetAxisを選択したか
＞大きく分けると２種類ある
・入力を直接みる判定
・InputManagerを介して入力判定　←Input,GetAxis()はこっち

＜入力を直接見る判定＞
if(Spaceキーを押した)			←特定のボタンやキー入力を受け取っている
{
	//処理する　
}
if(左クリックした)				←特定のボタンやキー入力を受け取っている
{
	//処理する
}
＜InputManagerを介する判定＞
if(設定したボタン、キーを押した)	←一度設定を中継する方法
{
	//処理する
}
↑どのようなメリットがあるかは仕様変更やマルチプラットフォームに対応しやすくなる

Unity一番上の編集Editープロジェクト設定ProjectSettingをクリック　←設定ウィンドウが開く
プロジェクト設定左側のInput Managerを押下▼を押下　←中身が展開する
▼水平Horizontalを展開　横軸
負方向ボタン　Negative Button	left	←コレを書き換えれば
性方向ボタン　Positive Button		right	←コレ			入力キーを変更出来る
キー入力は文字列で表すことが出来る　leftは「←」左矢印キー　rightは「→」右矢印キー　を押すと反応する
↓各種キーやボタンに対応する文字列が存在する
・通常キー		：a,b,c …
・数字キー		：1.2.3…
・矢印キー		：up, down, left, right
・キーパッド	：[1], [+], [equals]など
・修正キー		：right shift, left shift など
・マウスボタン	：mouse 0, mouse 1 …
・ジョイスティック	：joystick button 0 …
・特殊キー			：backspace, return など
・Functionキー		：f1, f2, f3 …

＜InputManagerのメリット＞
InputMangerを介さない場合　	Input.GetKey(”left”) ←キーの内容をプログラムに直接書くこととなる
キーを変更したい時やプラットフォームを変更したい時に全てのプログラムを書き換えなければならない
InputManagerを介す場合　	Input.GetAxis(”Horizontal”) ←設定の内容をプログラムに書く
プログラムを一切変更せず　キー入力を変更できる！　変更はInput Managerの設定を変えるだけでよい
何があるかわからないので変化に強いプログラムを書こう　別のゲームに流用できる

＜InputManager・判定方法＞InputManagerを介した判定方法もたくさん種類がある
GetButton		GetButton系は、そのボタンやキーを押したかどうか
GetButtonUp
GetButtonDown
GetAxis			GetAxis系は２つのボタンやキーから入力の方向をみる		←スムージング有り
GetAxisRaw													←スムージング無し
↑走る場合はこちらの方がいい　一つのボタンより左右の方向をみたほうがいいので
＜GetAxisの方向軸について＞
方向軸は−１〜１で表される
・例　Horizontalの場合
−１		０		１
 ←	    入力なし	→
<スムージング>　ジョイスティックなど　間の値を判定することが出来る　キーボードの場合は押した長さ
-1, 0, 1の間の少数まで判定する		スムージングなしの判定は-1, 0, 1の３種類のみ
スムージングにするかどうかはお好み　スムージングにする

InputManagerからスムージングを調整できる	無効 Dead 0.001
↓デフォルトでは予備キーが設定されている　←ボタン死んだので使うかもということで下記のように変更
負方向ボタン（副）　Alt Negative Button		a　→　z		左になる
性方向ボタン（副）　Alt Positive Button		b　→　x		右になる
=====================
void Update()
    {
        float horizontalKey = Input.GetAxis("Horizontal");

        if(horizontalKey > 0)		←右ボタンを押されている場合
        {
		transform.localScale = new Vector3(1, 1, 1);
   		anim.SetBool("run", true);
        }
        else if(horizontalKey < 0)	←左ボタンを押されている場合
        {
		transform.localScale = new Vector3(-1, 1, 1);
		anim.SetBool("run", true);
        }
        else						←入力なし　ボタンを押されていない場合
        {
		anim.SetBool("run", false);
        }
=====================
  SetBool(“パラメーター”名, 値);	アニメーターコントローラーで定義したbool型のパラメーターの値を指定した物に変更する
アニメーターのインスタンスにアクセスしセットブル、ラン、トルゥと書く　つまりrunフラグのtrueとなる
あと２つも同じようにして入力が無いときはfalseにする

PlayerスクリプトをヒエラルキーPlayer_standのコンポーネントを追加にドラッグアンドドロップ　（スクリプトを入れる）
▶実行してみると右を押しても左を押しても右に走るようになる

ゲームオブジェクトをマイナススケールにすると反転する　Xのスケールをーマイナスにすると左右が反転する
右を押すと右にいき　左をおすとマイナススケールで反転し左を向く　左右が変わったようにみえる
かえるちゃんが右を押したら右に走り　左を押したら　左に走るようになったが　ゲームビューがタイトル画面のままである
メインカメラを選択した状態で上のタブ　ゲームオブジェクトーアクティブ状態を切り替えるを2回押すとゲームビューが切り替わるが▶実行するともとに戻る

入力とアニメーションの制御が出来るようになった


＃３６　ステージを作成しよう
Step8	タイルマップを使おう
<Tilemapの導入>
Unity2017.2より前は動かない　Unity2017.2〜Unity2019.1は最初から入ってる　Unity2019.2以降はインストールが必要
上のメニューのウィンドウWindowーパッケージマネージャPackage Manager

↑真ん中▼のPackages:In ProjectをPacages: Unity Registryに変更する　少し出てくるまで時間がかかる　通信中 通信が完了すると項目が増える
パッケージマネージャPackage ManagerとはUnityに更に機能を追加できるもの
2D Tilemap Editorを選択し右下のインストールを押下する　in Projectにインストールされた　タイルマップ

やること　タイルマップを使うための下準備
ヒエラルキー右クリックー2D オブジェクト2D ObjectータイルマップTilemapを押下　←Gridというゲームオブジェクトが作成される
ヒエラルキーGridを選択した状態で上メニューのウィンドウWindowー２DータイルパレットTile Paletteを選択　←タイルパレットウィンドウが開く
新しいパレットを作成横のCreate New Palette▼をクリック

名前は作成するパレットの名前Name stage1　グリッドGridは配置する絵の形（短形Rectangle　角が直角の四角形）セルサイズは1マスの大きさ＞自動Automatic
作成Createを押下  
/Users/me-do/Desktop/unity/006/006/Assets/Tilemap/stage1.prefab
↑Assets配下にTilemapフォルダを作成して保存

やること　マップチップ作成
Pixelmatorを立ち上げる　新規作成　２のべき乗サイズ　幅128　高さ128　解像度960  ピクセル
#804B10  茶色
#179600　緑色
Assets > Texture にmap_ground1.pngとmap_ground2.pngを保存する
map_ground1.pngとmap_ground2.pngを選択してインスペクターのテクスチャタイプをスプライトに変更する　☑iOS用に上書きー適用する
map_ground2.pngをタイルパレットウィンドウへドラッグアンドドロップ　　すると保存先を聞かれるので下記に保存
/Users/me-do/Desktop/unity/006/006/Assets/Tilemap/map_ground2.asset
同様にmap_ground1.pngも実施　タイルパレットへマップチップを登録することが出来た
左クリック＞マップチップ選択　		ホイール＞視点ズーム		中ドラッグ＞視点の平行移動

↑アイコンお押下した後、マップチップを選択するとシーンビューのカーソル部分にマップチップが出現する
これをドラックすることでグリット上にマップチップを塗ることができる　２Dを選択していると塗りやすい　消しゴムで消すこともできる
タイルマップTilemapとは　Tile Paletteにマップチップを登録してグリッドに塗る機能
ステージの形に制限がでてきてしまうが簡単にステージをつくっていけるようになる

やること　当たり判定をつける
ヒエラルキーのTilemapを選択した状態でインスペクターのコンポーネントを追加から２Dタイルマップコライダーを追加
🔍tilemap Collider 2d　←検索ウィンドウで入力すると出てくる　緑の□がついて当たり判定が付いた状態となる
２DタイルマップコライダーTilemap Collider 2DとはTilemapで塗ったマップチップに自動で当たり判定を付けてくれるコンポーネント
細かい設定をしなくても当たり判定を一瞬で終わらせることができる　ただし…　位置を絶対に動かしてはいけない　□１つ１つが当たり判定なので動かすとめっちゃ重い！
例えば地面の揺れを表現したい場合は地面を揺らさずカメラを揺らす　地面にだけ当たり判定が付いている状態　プレイヤーにも当たり判定を付けていく

ヒエラルキーでプレイヤー(player_stand)を選択した状態でインスペクターのコンポーネントを追加から２Dカプセルコライダーを選択
🔍capsule collider 2d　←検索ウィンドウで入力すると出てくる　かえるちゃんの周りにカプセル型の当たり判定が付く

↑キャラクターに合わせて当たり判定を調整する　インスペクターのオフセットX[-0.1],Y[-0.12]とサイズX[1.6],Y[2.03]
何故カプセルコライダーを使用するか　←四角いコライダーだと角がつっかえるから　
🔍rigidbody 2d　←検索ウィンドウで入力　ヒエラルキーのコンポーネントを追加　２Dリジッドボディを追加　プレイヤーに物理演算を付与する
キャラクターがちゃんと地面に付くようになる
完了　ステージ制作基本部分
ToDo　ちゃんとしたステージにする


＃３７	キャラクターを移動させよう
Step9	移動方法を考えよう
＜Unityの移動方法＞
・無限パターン存在する　作りたいゲームによって方法が変わる　同じ方向で動きが違うものであったり　速度が違うものや　
見た目は同じ移動でも中身が全く違う種類の移動がたくさん存在する　まだまだたくさん種類がある　設定の組み合わせも違う
・物理演算を考慮しない移動					・物理演算を考慮する移動
・物理演算を考慮し、直前のフレームから補完する移動	・物理演算を考慮し、現在の速度から次のフレームの位置を予測して補完する移動
見た目が一緒ならいいのでは？　
・移動が早いと挙動が変わる	・ぶつかると挙動が変わる		
・処理の重さが違う　←何がどう重くなるのかが状況によって変わる場合がある　←重い処理が複数重なると症状がでるので原因に気付きづらい
物体の移動はよく考えよう
この解説ではマリオのような２Dアクションゲームを作っていきます　←同じ２Dアクションでも種類が違えば作り方が違う
違うタイプを作る場合は考え方だけ参考にしてください		作るゲームの形が違えば上手く行かない可能性がある

移動は大きく分けると２種類
・Transform操作	
Transform操作　←位置情報を直接制御する方法（ただ移動するだけ）ゲームオブジェクトの位置を動かすだけ
トランスフォームに触っていないつもりでもトランスフォーム操作されている場合があるので注意が必要
物理演算に関係するオブジェクトの場合、移動後再計算が走る　←Transform操作は基本的に軽いが物理演算に関係すると逆に重くなる
・物理エンジン操作
物理演算で位置を計算　移動する際、周囲を考慮した計算をしてくれる　Unity側が物理的計算を全てやってくれるので便利

マリオのようなゲームの場合
・当たり判定を利用したい　←物理エンジン操作が必要だが物理法則は無視する
空中でジャンプの軌道が変わる　動く床・２段ジャンプ・空中ダッシュ等
やること　物理的挙動を無視した物理エンジン操作で移動作成
プレイヤーのスクリプト（以前からの続き）Player.cs
=====================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed;							//③スピードを調整できるようにpublicで変数を定義する　インスペクターでスピードを調整できる

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;					//①リジッドボディ２Dの変数を用意してインスタンスに入れる（2D用と3D用がある）

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();			//②リジッドボディ２Dにアクセス出来るようになった
    }

    // Update is called once per frame
    void Update()
    {
        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float xSpeed = 0.0f;							//④左右のキーを押されたら横軸の速さを入れる変数を用意する

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = speed;							//⑤右を入力したらインスペクターで設定したスピードがでるプラス（速度6.66）正の速度
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = -speed;						//⑥左を入力したらマイナスをかけて反対方向になるようにする　負の速度　方向を指定
        }
        else
        {
            anim.SetBool("run", false);
            xSpeed = 0.0f;							//⑦何も押していない時　速度を0にする
        }
        rb.velocity = new Vector2(xSpeed, rb.velocity.y);	//⑧リジッドボディ２Dにアクセスしベロシティに値を代入
    }
}
=====================
Rigidbody2D.velocity　←重要ポイント　物理的挙動を無視した物理エンジン操作ができる
・RigidbodyもしくはRigidbody2Dから操作した場合、物理エンジンを使用する
velocityは速度を表す変数　ベロシティに値を代入するということは物体の速さを決めるということ
何故velocityに代入しただけで物理的挙動を無視するのか？
→□物体に様々な力がかかっている　物理的な働きから速度が算出される　その結果が→velocityに代入さる
　↓

①物理的な様々な計算←⑤破棄
②↓速度を算出
③velocity←④スクリプトから値を上書き
⑥↓移動位置を算出
⑦周囲の物との物理的な計算（当たり判定があるのもとぶつかっていないかなどの物理的な計算が行われる）衝突判定など

velocityに値を代入することで物理的な挙動を無視しつつ当たり判定などの物理演算をしてもらえる
Rigidbody2D.velocityで物体を操作する場合
◎物理法則を無視する動きに強く　マリオOK
✗物理法則に従った動きに弱い　　現実的なやつNG
ゲームを作る際は物理演算をどう使用するかを考えよう

								Y軸の速度をそのままに（いずれ変更する）
								↓
 rb.velocity = new Vector2(xSpeed, rb.velocity.y);	
						↑
						X軸の速度を指定したものに設定

ヒイラルキーplayer_standを選択した状態でインスペクターPlayer(Script)Speed 0 →1.06に変更する　0のままだと動かない　
このまま実行▶するとキャラクターがコケる
インスペクターのRigidbody 2DーConstraints ▼回転を固定Freeze Rotation☑Zをチェックする　Z軸で回転しなくなる 速度を4に設定


＃３８　	接地判定を作ってみよう
Step10	IsTriggerを使ってみよう　イズトリガー
走ったりジャンプするには地面についているかを判断する必要がある
やること　地面を認識する判定を作る
ヒエラルキーUntitledシーンを保存　player_standをGridの下にもってくる
player_stand右クリックー空のオブジェクトを作成Create Empty(プレイヤーの子に)　名前GameObject →GroundCheck
GroundCheckを選択した状態でコンポーネントを追加「🔍box」2D ボックスコライダー

↑細長くしてキャラ判定の下に
インスペクターBox Collider 2D トリガーにするIs Trigger☑つける
Is Triggerイズトリガーとはコライダーの当たり判定が無くなる　代わりに判定内に入った物を取得できるようになる　この判定で地面を取得する
プロジェクトAssets>Script右クリックー作成ーC# スクリプト　名前：GroundCheck
ボックスコライダー２Dの判定の中に何かが入ったかどうかを調べるスクリプトを書いていく　ちゃんと動作するかの確認スクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GroundCheck : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }


    private void OnTriggerEnter2D(Collider2D collision)	//必ずこの通りに書く　OnTriggerEnter2Dというメソッド
    {
        Debug.Log("何かが判定に入りました");
    }


    private void OnTriggerStay2D(Collider2D collision)	
    {
        Debug.Log("何かが判定に入り続けています");
    }


    private void OnTriggerExit2D(Collider2D collision)	
    {
        Debug.Log("何かが判定を出ました");
    }
}
=====================
OnTriggerEnter2D　Unity側から呼ばれる特別なメソッド
メソッド名、引数の種類を決められた形にするとUnity側からこのメソッドを呼ぶ　その為、必ずこの通りに書く

<OnTriggerEnter2Dが呼ばれる条件>全て満たす必要あり
1.	Is Triggerな2Dコライダーがそのゲームオブジェクトもしくは子オブジェクトについている
スクリプトがついているゲームオブジェクト(GroundCheck)にIs Triggerなコライダー(かえるちゃんの下の細長い□)がついている

2.	そのゲームオブジェクト、もしくは親、もしくは相手の方にRigidbody2Dがついている
親オブジェクト(▼Player)にRigidbody2DがついているのでOK

3.	Is Triggerな２Dコライダーの判定内に別の2Dコライダーが侵入した
細長い□に地面が入ってくればOK　地面の方にはタイルマップ２Dが入っているのでコライダーである

OnTrigger系のメソッドは他にも種類がある Is Triggerへの侵入を検知する特別なメソッド
OnTriggerEnter2D	判定内に２Dコライダーが侵入したら呼ばれる
OnTriggerStay2D	判定内に２Dコライダーが入り続けていたら呼ばれる
OnTriggerExit2D	判定内から２Dコライダーが出たら呼ばれる
↑これらのメソッドを使い分けることで現在の足物を調べられる

ヒエラルキーplayer_standを選択した状態で実行▶
[挙動]							[Debug.Log]
キャラクターが着地					何かが判定に入りました
キャラクターが地面に接触し続けている	何かが判定に入り続けています
キャラクターが地面から落ちる			何かが判定を出ました
↑判定は取ることが出来た

やること　判定に入ったものが地面かどうかを判別できるようにする　地面が侵入したか判別する
ヒエラルキーTilemapを選択した状態でインスペクターのタグUntagged▼タグを追加…Add Tag…　←自分の好きなタグを追加できる
これが地面だと解るタグを追加してゲームオブジェクトに付けていく　地面だとわかるタグを追加する
タグ　リストは空ですList is Empty右下の＋を押下  追加するタグの名前；Ground を入力してSaveを押下　←タグを追加できた　Tag 0 Ground
もう一度ヒエラルキーTilemapを選択　もう一度　タグUntagged▼を押下すると先程追加したタグGroundを選択　←Tilemapに地面用のタグを付けることができた

次はスクリプト側で判定内に侵入したコライダーが地面なのかどうかを判別していく
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GroundCheck : MonoBehaviour
{
    private string groundTag = "Ground";			//プログラムを書きやすくする為、ストリング型の変数にタグを同じ文字列(Ground)を使用	

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }


    private void OnTriggerEnter2D(Collider2D collision)		//判定内に入った２Dコライダー（タイルマップ２Dが含まれる）
    {
        if (collision.tag == groundTag)			//判定内に入った２Dコライダーが張り付いているゲームオブジェクトのタグを見ることが出来る　タグの名前がGroundなら通る
        {
            Debug.Log("地面が判定に入りました");
        }
    }


    private void OnTriggerStay2D(Collider2D collision)
    {
        if (collision.tag == groundTag)			//地面の判定ができるようになる　上と同じメソッド
        {
            Debug.Log("地面が判定に入り続けています");
        }
    }


    private void OnTriggerExit2D(Collider2D collision)
    {
        if (collision.tag == groundTag)			//地面の判定ができるようになる　上と同じメソッド
        {
            Debug.Log("地面が判定を出ました");
        }
    }
}
=====================
[挙動]							[Debug.Log]
キャラクターが着地					地面が判定に入りました		Enter
キャラクターが地面に接触し続けている	地面が判定に入り続けています	Stay
キャラクターが地面から落ちる			地面が判定を出ました			Exit

タグを元に戻すとログが表示されない　Ground→Untagged　←ちゃんとタグが機能していたことが解る　確認が終わらったら　タグをGroundに戻す　地面を取得することが出来た
やること　接地判定を作る

GroundCheck.cs　←接地判定のスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GroundCheck : MonoBehaviour
{
    private string groundTag = "Ground";
    private bool isGround = false;						//①接地判定用のフラグ
    private bool isGroundEnter, isGroundStay, isGroundExit;	//②3つのフラグを作成する

    //物理判定の更新毎に呼ぶ必要がある					//欠点：Unityの物理演算の判定のたびにこのメソッドを呼ぶ必要がある
												//各種オントリガーメソッドに使っているフラグを下ろしてあげる(false)必要がある為このような制約ができる
												//もっといい書き方があるが今の段階では難しいので今回はコメント対応で妥協
    public bool IsGround()								//⑥プレイヤーのスクリプトから読めるようにpublicでメソッドを書いていく　返り値として地面にちゃんと設置しているかを返す
    {
        if(isGroundEnter || isGroundStay)					//⑦EnterもしくはStayを通っていた場合、接地判定をtrueにする
        {
            isGround = true;
        }
        else if (isGroundExit)							//⑧Exitを通っていた場合、接地判定をfalseにする　Exitを通っていた場合でもEnterかStayが呼ばれたら、地面に着いているとみなす
        {											//またelse文が無い為、どのメソッドも通っていない場合、isGround(接地判定フラグ)はそのままとなる
            isGround = false;								//キャラクターがしばらく止まるなどしてStayが呼ばれない状態となったとしても対応できる
        }

        isGroundEnter = false;							//⑨呼び出されたら各種フラグをfalseにして元の状態に戻す
        isGroundStay = false;
        isGroundExit = false;
        return isGround;								//⑩接地判定を返す
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.tag == groundTag)
        {
            isGroundEnter = true;							//③それぞれのフラグをそれぞれのメソッドでtrueにする（trueになったらこのメソッドを通ったとみなす）
        }
    }

    private void OnTriggerStay2D(Collider2D collision)
    {
        if (collision.tag == groundTag)
        {
            isGroundStay = true;							//④それぞれのフラグをそれぞれのメソッドでtrueにする（trueになったらこのメソッドを通ったとみなす）
        }
    }

    private void OnTriggerExit2D(Collider2D collision)
    {
        if (collision.tag == groundTag)
        {
            isGroundExit = true;							//⑤それぞれのフラグをそれぞれのメソッドでtrueにする（trueになったらこのメソッドを通ったとみなす）
        }
    }
}
=====================
＜接地判定＞
・地面が判定内に入る　	→ true
・地面が判定内から出る	→ false
↑ではちょっと足りない
プレイヤーの進行方向→　←床の進行方向
↑地面から出た		　　↑地面に入った
！同時に起きる事があるのでEnterとExitだけでは不十分　falseのままになってしまう
OnTriggerStay2Dで居続けるのを判定しては？
Stayで呼ばれている時　true 呼ばれていない時　false　←✗出来ません　しばらく止まっているとOnTriggerStay2Dは呼ばれなくなる　←処理負荷軽減の為、動いていないものを処理しなくなる
止まり続けると地面から離れたとみなされる


ちょっと不格好だが接地判定が出来たのでプレイヤーほうで呼び出していく
↓プレイヤーのスクリプト
Player.cs
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed;
    public GroundCheck ground;					//①パブリックでシリアライズ化し、GroundCheck.csからインスペクターから設定できるようにする

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;					//②接地判定を入れておく変数を用意する

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()							//④Fixedを追記
    {
        //接地判定を得る
        isGround = ground.IsGround();				//③接地判定のスクリプトのインスタンスから先程作ったメソッドを使って接地判定フラグを受け取る
											//これで様々なアクションを作る際、地面に着いているかどうかを判別することができる
        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal”);		//FixidUpdateが呼ばれなくても次のフレームで押し続けていればOK
        float xSpeed = 0.0f;

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            xSpeed = 0.0f;
        }
        rb.velocity = new Vector2(xSpeed, rb.velocity.y);		//速度を入れている　FixedUpdateが連続で呼ばれても何も変わらない
    }
}
=====================
後はパブリックからインスペクターで設定できるようにしたのでヒエラルキーのPlayer_standを選択した状態で
Player(スクリプト)のGround⦿を押下　シーンGroundCheckスクリプトを選択　（ドラッグアンドドロップできなかった）


＃39　FixedUpdateについて
・FixedUpdateとは・Updateとの使い分け
Unity側が呼び出す特別なメソッド
Update > 毎フレーム呼ばれる　FixedUpdate > 一定間隔で呼ばれる
						↑フレームレートに依存しないと解説されることが多い　←勘違いの元　現実時間ではなくゲーム内時間で一定間隔
・物理演算の処理の前に毎回呼ばれる　→　物理演算ってどういうタイミング？　→ゲーム内時間で一定間隔呼ばれる
＜FixedUpdate＞
 物理演算の前にしたい処理を書く
フレームレートは現実時間の流れと同じ　処理が間に合わず落ちてしまう場合がある
現実時間に合わせた場合、一定の時間で処理できるとは限らない　→物理的なシュミレーションがうまくいかないケースが出てくる
（先の予測が必要なものなど）別の時間の概念が必要　→ゲーム内時間
現実時間の流れ　→線　ゲーム時間の流れ　｜進｜進｜　進　　｜進　｜進　　　　｜進　点　一つ一つで一定時間進める　
どうみても一定間隔ではないが進めている時間が一定　現実時間でバラバラな処理でもゲーム内では一定間隔で処理される
｜進←このタイミングでFixedUpdateが呼ばれる　FixedUpdateの次に物理演算も行われるので物理演算もこのタイミング呼ばれる
↑この中でゲーム内時間更新→FixedUpdate→物理演算が呼ばれている
ーーーーーーーーーーーゲーム内時間流れーーーーーーーーーーーーー

◇UpdateとFixedUpdate◇

Updateは1フレームの間に必ず呼ばれる
FixedUpdateは1フレームの間に呼ばれたり呼ばれなかったり、複数回呼ばれたりする
FixedUpdateが呼ばれる回数がどのような基準になっているかというと
Unity上メニューー編集Editープロジェクト設定ProjectSettigー時間Timeを押下
固定時間ステップFixed Timestep 0.02 ゲーム内時間を進める秒数　0.02秒づつゲーム内時間が更新される
30FPSは一秒間に30回フレームを出力している　1÷30=0.033333…←1フレームあたり秒　画像出力現実時間0.03→ 0.06→ 0.09秒
｜		0.03|			｜		0.06|		｜			0.09|				3回呼ばれた　Update
↑FixedUpdate 0秒			↑0.02秒				↑0.04秒、0.06秒					4回呼ばれた　FixedUpdate
ゲーム内時間　一回呼ばれる	固定時間ステップ秒　		0.09秒を超えない範囲で2回呼ばれる
FixedUpdateはゲーム内時間と現実時間がなるべく同じ様になるように処理される

しかしながら現実時間とゲーム時間が大きく離れるケースがある
		　3.333…
ーー・・・→｜
処理落ちした
3.333…÷0.02=166.666…
166回FixedUpdateを呼ばなくてはいけない　←処理が重すぎる
先程の時間ウィンドウで最大許容時間ステップMaximum Allowed Timestep で1フレームで進められる限界の時間が決められている 0.3333333
この限界時間以上にゲーム時間を進められない

03.333…
ーー・・・→｜
処理落ちした
0.3333333までしか進められない　0.333…÷0.02=16.666666…　となりFixedUpdateは16回呼ばれる
＜FixedUpdateの呼ばれ方＞※Fixed Timestepがデフォルトの場合
フレームレートが高いと1フレーム内で呼ばれない場合が多くなる　←1フレームの秒数が0.02より下回るから(60FPS 1÷60=0.01666…)
|0.016	0.032|	0.048|	0.064|	0.08		0.096|	0.112|	0.128|	0.144|	0.16		0.176|	0.192|
逆にフレームレートが低いと1フレーム内で複数回呼ばれやすくなる
！FixedUpdateに重い処理を書くとフレームレートが落ちた時に複数回呼ばれる場合が多くなる為、重い時、重さが更に加速する
物理演算に関係する処理だからといって何も考えずに突っ込むのはやめましょう

◇入力とFixedUpdate◇
ボタン入力→物理演算で動かす←よくある
↑
ボタン入力は1フレーム内で一回判定　FixedUpdateは1フレーム内で呼ばれたり呼ばれなかったりする

↓例えばこのようなコードがあったとします
//Start等でインスタンスを取得している物とする
private Rigidbody r;
private void FixedUpdate()
{
	if (Input.GetKeyDown(KeyCode. RightArrow))　←「→」右矢印キーを押した瞬間だけtrueになる
	{
		r.AddForce(Vector3.right, ForceMode. Impulse);　←右側の方向に瞬間的に力を加える命令
	}	↑
}		↑
		物理演算に関係する処理なのでFixedUpdateに書くのが一見正しいように見えるが…

順番に処理をみていく
①まずFixedUpdateが呼ばれ物理演算処理が終わった後、入力判定が行われます
	入力判定
	｜
	→ー｜→ー｜→ー｜
↑	｜	
↑	FixedUpdate
↑
②この判定の手前でボタンを押していた場合↓
	入力判定
	｜	｜←この間　（③Input.GetKeyDownは次の入力判定までtrueになる）
	→ー｜　ー｜→ー｜
	　　　↑
	④FixedUpdateが呼ばれなかった場合はどうなる？
	⑤FixedUpdateが呼ばれていないのでボタンを入力したのに処理が行われない
	入力判定←こちらがtrueとは限らない
	｜	｜
	→ー｜　ー｜→ー｜
	↑		　↑
			　FixedUpdate
	⑥次でFixedUpdateが呼ばれたとしても入力がtrueとは限らない
FixedUpdateで瞬間的に入力すると入力がなかった事になる場合がある

逆に処理落ちなどしてFixedUpdateが16回呼ばれた場合
入力判定←こちらがtrueとは限らない
	｜	｜
	→ー｜→ー｜→ー｜
	　　　↑
		FixedUpdate16回
瞬間的な力が１６連打される　すさまじい勢いで右側に吹き飛んでいく
入力とFiexdUpdateはよく考えて使用する

＜今までの解説＞今つくっているやつは大丈夫？
Input.GetAxis(“Horizontal”);
↑押しっぱなしを判定
FixidUpdateが呼ばれなくても次のフレームで押し続けていればOK
Rigidbody.velocity
↑速度を入れている　
FixedUpdateが連続で呼ばれても何も変わらない

何故FixedUpdateにしたか
・Updateで速度を指定すると物理演算が連続で呼ばれた時、摩擦等で減衰してしまう為
物理演算が何回も呼ばれてしまうと速度の入れ直しが行われないまま物理演算が行われてしまうので一定の速度にしたつもりが減衰が起こる

・接地判定のフラグを物理演算前に降ろして物理演算でまた判定し直したい為
オントリガーエンター、ステイ、イクジットのフラグを物理演算の前に降ろしておかないと前の物理演算のフラグがそのままになってしまい
前のものが分からなくなってしまうので物理演算前に呼ばれるFixedUpdateにしたわけです　

＜FixedUpdate まとめ＞
・物理演算の前に毎回呼ばれる
・そのタイミングはゲーム内時間で一定間隔で呼ばれる
・１フレームの間に呼ばれなかったり複数回呼ばれたりする

・物理演算の前にしたい処理を書こう
・可能なら重い処理は他へ逃がそう
・瞬間的な処理は相性が悪いので書く場合はよく考えてから


＃４０	ジャンプを作ってみよう
Step10	物理演算を無視したジャンプ

スクリプトを書き写したい場合↓
Unity 2Dアクションの作り方【ジャンプ】【高さを押した長さで変更可】 | ゲームの作り方！

やること　押した長さで高さが変わるジャンプを実装する
ヒエラルキーplayer_standを選択した状態でRigidbody 2D 重力スケールGravity Scaleを１→０に変更 　←これで重力が働かなくなる
Y軸の物理演算を止めて自前の物に変更していく　＃３７でX軸は完了　今回はY軸やるで
プレイヤーのスクリプトをビジュアルスタジオで開く
Player.cs
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度			//⑤ジャンプ速度をインスペクターで設定でき調整しやすくする　変数を作成
    public float gravity; //重力　					//①重力の値をインスペクターで設定できるようにする為　変数を作成
    public GroundCheck ground; //接地判定

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float verticalKey = Input.GetAxis("Vertical");		//⑥↑縦軸のキー入力を受けとる  バーティカル
											//キー入力は#35参照　次は地面についている時ジャンプできるようにする
        float xSpeed = 0.0f;
        float ySpeed = -gravity;						//②Y軸のスピードをプログラムから調整できるように変数を作成
											//Y軸に対して何もしていない時　重力を働かせる　その為、初期値に値を設定する
        if(isGround)								//⑦地面についている時で（地面から離れた場合の処理が足りない）
        {										//接地判定は#38参照
            if(verticalKey > 0)						//↑上方向のキーが入力されている時
            {
                ySpeed = jumpSpeed;					//Y軸の速度を設定したものになるようにする
            }
        }

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            xSpeed = 0.0f;
        }
        rb.velocity = new Vector2(xSpeed, ySpeed);		//③リジッドボディ２Dに渡している速度のY軸をこちらで指定したものに変更する
    }											//変数(xSpeed, ySpeed)を調整すればキャラクターを好きな速度で動かすことができる
}
=====================
④インスペクターで重力の値を設定する
ヒエラルキーplayyer_standを選択した状態でインスペクターPlayer(スクリプト)重力Gravity0→3を入力
この状態で実行▶すると自前の重力がキャラクターにかかる　次はジャンプを作っていく
⑧インスペクターでジャンプスピードの値を設定する
ヒエラルキーplayyer_standを選択した状態でインスペクターPlayer(スクリプト)Jump Speed0→5を入力
この状態で実行▶するとぴょこぴょこ動くだけでジャンプできない
地面から離れた場合の処理が足りないので次はジャンプ中の処理を書いていく

=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度
    public float gravity; //重力
    public GroundCheck ground; //接地判定

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isJump = false;					//①ジャンプしているかどうかのフラグを作成

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float verticalKey = Input.GetAxis("Vertical");

        float xSpeed = 0.0f;
        float ySpeed = -gravity;

        if (isGround)
        {
            if(verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                isJump = true;							//②↑キーが押されている場合true
            }
            else
            {
                isJump = false;						//↑キーが押されていない場合false
            }
        }
        else if (isJump)							//③ジャンプ中の処理を追加
        {
            if(verticalKey > 0)
            {
                ySpeed = jumpSpeed;					//↑キー押している場合はジャンプ速度にする
            }
            else
            {
                isJump = false;						//↑キー押していないならジャンプフラグをfalseにする
            }
        }

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            xSpeed = 0.0f;
        }
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }
}
=====================
この状態で実行▶するとジャンプはできたが無限にジャンプできてしまうので次はジャンプに制限をつける

Player.cs　　
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度
    public float jumpHeight; //ジャンプする高さ		//②インスペクターでジャンプする高さを設定できるようにする
    public float gravity; //重力
    public GroundCheck ground; //接地判定

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isJump = false;
    private float jumpPos = 0.0f;				//①ジャンプした位置を記録する変数を作る

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float verticalKey = Input.GetAxis("Vertical");

        float xSpeed = 0.0f;
        float ySpeed = -gravity;

        if (isGround)							//←地面から
        {
            if(verticalKey > 0)					//←ジャンプした時
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する　//③←高さを保存
                isJump = true;
            }
            else
            {
                isJump = false;
            }
        }
        else if (isJump)
        {
            //上ボタンが押されているかつ、現在の高さがジャンプした位置から自分が飛べる高さより下にいる時、上昇する
            if(verticalKey > 0 && jumpPos + jumpHeight > transform.position.y)　//④←地面でジャンプした位置から＋ジャンプできる高さ＝飛べる高さ
            {														　//飛べる高さ＞自分のY座標　の場合true
                ySpeed = jumpSpeed;
            }
            else
            {
                isJump = false;
            }
        }

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            xSpeed = 0.0f;
        }
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }
}
=====================
⑤インスペクターのPlayer(スクリプト)Jump Heightを0→3に変更する　ジャンプする高さ
この状態で実行▶すると　とりあえずジャンプするようになる　高さ制限付き　まだ足りない　
Unity上メニューウィンドウー２Dータイルパレットを表示し、適当に空中にブロックを作る
空中のタイルパレットに頭をぶつけると無限に飛べてしまう　これを直していく

ヒエラルキーGroundCheck右クリックー複製Duplicateー名前：HeadCheck 　頭用
↓その判定をキャラクターの頭の上にもってくる

この判定内に地面が入ったら上昇を止める

Player .csを編集する
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度
    public float jumpHeight; //ジャンプする高さ
    public float jumpLimitTime; //ジャンプ制限時間		//②何かにつっかえた時の為、ジャンプに制限時間を追加　
    public float gravity; //重力
    public GroundCheck ground; //接地判定
    public GroundCheck head; //頭をぶつけた判定		//①インスペクターで設定できるようにpublicに設定

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isHead = false;					//③頭をぶつけたフラグを追加
    private bool isJump = false;
    private float jumpPos = 0.0f;
    private float jumpTime = 0.0f;					//④滞空時間を計る変数を追加

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();
        isHead = head.IsGround();					//⑤接地判定の時と同じ用に頭の判定もとっていく

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float verticalKey = Input.GetAxis("Vertical");

        float xSpeed = 0.0f;
        float ySpeed = -gravity;

        if (isGround)
        {
            if(verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する
                isJump = true;
                jumpTime = 0.0f;						//⑥ジャンプしている時間を計りたいのでジャンプした時、時間をリセットする
            }
            else
            {
                isJump = false;
            }
        }
        else if (isJump)							
        {
            //上方向キーを押しているか					//⑦見づらくなってきたので条件式を分解　条件を変数に入れて見やすくしていく
            bool pushUpKey = verticalKey > 0;
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + jumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか			//⑧左記の判定を追加
            bool canTime = jumpLimitTime > jumpTime;	//制限時間＞ジャンプしている時間でtrueになる

            if(pushUpKey && canHeight && canTime && !isHead)	//⑨if文に書いていく上方向キーを押しているかつ飛べる高さより下にいるかつ
            {												//ジャンプの時間がオーバーしていないかつ頭ぶつけていない時上昇する
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;						//⑩ジャンプ中の時間を計る　ジャンプ時間を計測する変数にTime.deltaTimeを足す
            }												//上昇している間に進んだゲーム内時間を毎回足すのでその合計はジャンプで上昇している時間になる
            else											//経過時間を毎回足すことによって時間を計測できる
            {
                isJump = false;
                jumpTime = 0.0f;								//⑪上昇できなくなった時時間をリセットする
            }
        }

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            xSpeed = 0.0f;
        }
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }
}
=====================
頭ぶつけていない判定についてはFixedUpdateが呼ばれるたびに更新する必要がある為if文の中には書かない（ isHead）
Time.deltaTime	最後のフレームからの通過時間（秒）　FixedUpdate内ではゲーム内時間を進める秒数　ゲーム内時間＃３９
プログラムが出来たらインスペクター設定を忘れないようにする

Player(Script)
Speed 速度		4
Jump Speed		5
Jump Height		3
Jump Limit Time	5
Gravity 重力		5
Ground			GroundCheck	(GroundCheck.cs)
Head 頭			HeadCheck	(GroundCheck.cs)		⦿から選択する
この状態で実行▶すると上の地面に頭をぶつけるとちゃんと降りるようになる

やること　ジャンプアニメーションをつける
上メニューのウィンドウWindowー アニメーションAnimationー アニメーターAnimatorを選択して　アニメーターウィンドウを開く　アニメーション制御＃３５

◇ジャンプ　上昇モーション
アニメーターウィンドウのplayer_stand右クリックー遷移を作成ーplayer_jump_upに→やじるしをくっつける
同じようにしてplayer_run右クリックー遷移を作成ーplayer_jump_upに→
アニメーターウィンドウのパラメーターを選択した状態で＋Bool 名前をjumpにする

→をクリックしてインスペクターから▶Settingsをクリックー終了時間ありHas Exit Time☑を外すと遷移時間(s)Transition Duratior0.25→0にする
Conditions リストは空です右下の＋を押下し　run▼をクリックしてjumpに変更　jump true
jumpフラグがtrueの時jumpフラグに遷移するようにする
→も→と同様な設定にする

◇ジャンプ下降モーション
player_jump_up右クリックー遷移を作成ーplayer_jump_downに→やじるしをくっつける
→も→と同様な設定にするがjump trueではなくjump falseと設定する

player_jump_downからplayer_standへ←を引っ張る	ground : true	jump : false	Has Exit Time□	遷移時間0
player_jump_upからplayer_standへ←を引っ張る	ground : true	jump : false	Has Exit Time□	遷移時間0
アニメーターウィンドウのパラメーターを選択した状態で＋Bool 名前をgroundにする

ジャンプせずに落下する場合がある為の設定↓
player_stand→player_jump_down	ground : false	Has Exit Time□	遷移時間0
player_run→player_jump_down	ground : false	Has Exit Time□	遷移時間0


player_standを選択　インスペクターTransitions配下に立ち状態からの矢印一覧が表示されている　上の矢印が優先される

↑優先したい矢印を上にもっていく
1.上昇
2.下降
3.走り
同じ用に走りモーションも設定する　player_run

アニメーションをループさせたくない場合は
プロジェクトーAssets ーAnimation ーplayer_jump_downを選択
インスペクターのループ時間Loop Time☑を外す

後はアニメーションのフラグに今の状態を渡してあげる

=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度
    public float jumpHeight; //ジャンプする高さ
    public float jumpLimitTime; //ジャンプ制限時間
    public float gravity; //重力
    public GroundCheck ground; //接地判定
    public GroundCheck head; //頭をぶつけた判定

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isHead = false;
    private bool isJump = false;
    private float jumpPos = 0.0f;
    private float jumpTime = 0.0f;

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();
        isHead = head.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float verticalKey = Input.GetAxis("Vertical");

        float xSpeed = 0.0f;
        float ySpeed = -gravity;

        if (isGround)
        {
            if(verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する
                isJump = true;
                jumpTime = 0.0f;
            }
            else
            {
                isJump = false;
            }
        }
        else if (isJump)
        {
            //上方向キーを押しているか
            bool pushUpKey = verticalKey > 0;
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + jumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか
            bool canTime = jumpLimitTime > jumpTime;

            if(pushUpKey && canHeight && canTime && !isHead)
            {
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;
            }
            else
            {
                isJump = false;
                jumpTime = 0.0f;
            }
        }

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            xSpeed = 0.0f;
        }

        anim.SetBool("jump", isJump);
        anim.SetBool("ground", isGround);
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }
}
=====================
この状態で実行▶するとちゃんとアニメーションする


＃４１	移動を滑らかに表現しよう
Step11	アニメーションカーブを使ってみよう
＜いままで作ったもの＞ずっとキャラクターの速度が同じ　Rigidbody2D.velocityに固定値を入れているので一定速度になる
動きにメリハリがないので工夫してみる
移動　	→　だんだん早く
ジャンプ	→　最初は早く頂点ではゆっくり

プレイヤーのスクリプト Player.cs 
=====================
//インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度
    public float jumpHeight; //ジャンプする高さ
    public float jumpLimitTime; //ジャンプ制限時間
    public float gravity; //重力
    public GroundCheck ground; //接地判定
    public GroundCheck head; //頭をぶつけた判定
    public AnimationCurve dashCurve;			//パブリックでアニメーションカーブの変数を作成する　ダッシュ用の変数
    public AnimationCurve jumpCurve;			//パブリックでアニメーションカーブの変数を作成する　ジャンプ用の変数
=====================
ヒエラルキーのplayer_standを選択した状態でインスペクターのスクリプトを見ると下記の灰色のDashCurve■をクリックする

AnimationCurveとは時間からカーブで設定した値を得るもの　時間経過での数値の変化を表現するのに便利
カーブウィンドウが開く　デフォルトの状態↓
1.0	
	↑返す値
0.5	
		　→時間
0	　0.5	　1.0
線が／の場合、0.5秒の時の値を教えてと言うと0.5の値を返してくれる　　速度×時間で大きくなる値→加速する表現になる
右クリックで編集点を追加できる
編集点右クリックEditKeyで点の縦横の座標を数値で指定することができる
編集点右クリックブロークンBrokenでハンドルが両側で連動しなくなる
ブロークンされたハンドルは編集点右クリックフラットFlatで元に戻すことができる
編集点右クリックDelete Keyで編集点を消すことができる
端っこの⚙歯車を左クリックするとループLoopさせたり折返しループPing Pongさせることができる

ダッシュ用

↑Dash Curve 最高速に早く達する形に↗   頂点の大きさ1.0　初速を早く↑　←最高速に達する時間を短く
下	0.000	0.100
上	0.500 	1.000

ジャンプ用

上		0		1
真ん中	0.85		0.725
下		1		0.65
初速を早く　上昇するにつれゆっくりになるようにしている　　ポイントは終点を0にしない
0にしてしまうとジャンプ中に失速してしまうので挙動がおかしくなる

playerのスクリプト　移動とジャンプに↑を適用していく
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度
    public float jumpHeight; //ジャンプする高さ
    public float jumpLimitTime; //ジャンプ制限時間
    public float gravity; //重力
    public GroundCheck ground; //接地判定
    public GroundCheck head; //頭をぶつけた判定
    public AnimationCurve dashCurve;
    public AnimationCurve jumpCurve;

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isHead = false;
    private bool isJump = false;
    private float jumpPos = 0.0f;
    private float jumpTime = 0.0f;
    private float dashTime = 0.0f;				//①ダッシュ用の時間計測の変数
    private float beforeKey = 0.0f;				//②前の入力を保存しておく変数

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();
        isHead = head.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float verticalKey = Input.GetAxis("Vertical");

        float xSpeed = 0.0f;
        float ySpeed = -gravity;

        if (isGround)
        {
            if(verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する
                isJump = true;
                jumpTime = 0.0f;
            }
            else
            {
                isJump = false;
            }
        }
        else if (isJump)
        {
            //上方向キーを押しているか
            bool pushUpKey = verticalKey > 0;
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + jumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか
            bool canTime = jumpLimitTime > jumpTime;

            if(pushUpKey && canHeight && canTime && !isHead)
            {
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;
            }
            else
            {
                isJump = false;
                jumpTime = 0.0f;
            }
        }

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            dashTime += Time.deltaTime;			//③横へ移動している時、時間を計測する　ダッシュ中の時間を計測
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            dashTime += Time.deltaTime;			//③横へ移動している時、時間を計測する　ダッシュ中の時間を計測
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            dashTime = 0.0f;						//④止まったら0に　止まったら時間をリセットする
            xSpeed = 0.0f;
        }

        //前回の入力からダッシュの反転を判断して速度を変える
        if(horizontalKey > 0 && beforeKey < 0)
        {
            dashTime = 0.0f;
        }
        else if(horizontalKey < 0 && beforeKey > 0)
        {
            dashTime = 0.0f;
        }
        beforeKey = horizontalKey;

        //アニメーションカーブを速度に適用
        xSpeed *= dashCurve.Evaluate(dashTime);
        if(isJump)
        {
            ySpeed *= jumpCurve.Evaluate(jumpTime);
        }

        anim.SetBool("jump", isJump);
        anim.SetBool("ground", isGround);
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }
}
=====================
⑤前のキー入力と反対のキーを押したらダッシュの継続時間をリセットするようにする
前回のキー入力と今回の入力の方向が違う場合という条件で判定し、ダッシュの継続時間を0にする
キー入力が反対になる　つまり反転した場合　加速をリセットするようになる
⑥Xの移動速度にアニメーションカーブをかけてあげれば加速の表現になる
ダッシュ用のアニメーションカーブに.Evaluateと書く
AnimationCurve.Evaluate(時間)　アニメーションカーブから指定された時間の値を返す
先程のアニメーションカーブをグラフで作成していたものを実行するメソッドとなる
⑦ジャンプも同様にする　ジャンプの時間は前回作ったものをそのまま流用する

移動とジャンプにちょっとした色をつけることができた



＃４２	カメラを追従させてみよう
Step12	Chinemachineを使ってみよう
キャラにカメラがついてくるように　Chinemachineという機能を使用
やること　ChinemachineをUnityに追加　シネマシーンはデフォルトのUnityに入っていない
上メニューのウィンドウWindowーパッケージマネージャPackage Manager   ウィンドウが開く　Packages:Unity Registry▼に変更
Chinemachineを選択　Unityバージョン2020.1.1f1ではChinemachine2.6.2をインストールしようとすると下記エラーとなりインストール出来ない

An error occurred(Unable to add package[com.unity.cinemachine@2.6.2]:
Cannnot fetch authorization code. User access token is expired or user is not logged in.). See console for more details.
Smart camera tools for passionate creators. 
エラーが発生しました(Unable to add to package[com.unity.cinemachine@2.6.2].
Cannnot fetch authorization code. ユーザーアクセストークンの有効期限が切れているか、ユーザーがログインしていません。) 詳細はコンソールを参照してください。情熱的なクリエイターのためのスマートカメラツール。

IMPORTANT NOTE: If you are upgrading from the Asset Store version of Cinemachine, delete the Cinemachine asset from your project BEFORE installing this version from the Package Manager.
重要：CinemachineのAsset Storeバージョンからアップグレードする場合は、パッケージマネージャからこのバージョンをインストールする前に、プロジェクトからCinemachineのアセットを削除してください。

Unity 2020.1 からパッケージマネージャで発見できなくなったパッケージのインストール方法 – ユニティ・テクノロジーズ・ジャパン合同会社
↑Unity日本語ヘルプデスクにUnity 2020.1からCinemachineのインストール方法が記載

動画のコメントに書き投稿があり
2020年6月にCinemachine ver2.6が出ているようですがUnity2019.4.4f1にインストールしようとするとエラーが出ました。Cinemachine ver2.5だと問題なくインストールできたので最新版は不具合があるのか相性の問題だと思います。自分が引っ掛かった個所なのでメモ代わりに残しておきます。

＜解決策＞
パッケージマネージャの左上の＋ボタンから Add package from git URL を選択し、下記パッケージ名を入力
com.unity.cinemachine@2.5

↑ちゃんとインストールされるとプロジェクトのパッケージの中にシネマシーンが追加される
シネマシーン自体を勝手に配布・販売✗　シネマシーンを使って作ったゲームを配布・販売○　著作権は私にある

上メニューにChinemachineが追加されているのでこれをクリックしてCreate 2D Cameraを選択すると
CM vcam1（CMVカム１）というゲームオブジェクトがヒエラルキーに作成される
ヒエラルキーのMain Cameraを選択するとインスペクターにCinemachineBrainシネマシーンブレインというコンポーネントが新たに作成されている

やること　カメラをプレイヤーに追従するようにする
ヒエラルキーのCM vcam1を選択した状態でインスペクターCinemachineVirtualCameraのFollow⦿をクリックするとウィンドウが立ち上がるので
シーンのplayer_standを選択する
↓CM vcam1を選択した状態でゲームビューにすると変な枠が表示される

↑タイトルシーンがずっとじゃまなので消したい
Unity：ヒエラルキー（Hierarchy）ビューの使い方 | Unity+AssetStoreおすすめ情報
＜解決策＞
シーンを保存した後にプロジェクトAssetsーScenes　UnitledをダブルクリックでUnitiledのみヒエラルキーに表示される

カメラがカエルちゃんを追いかけるようにできた　が画面外までついていってしまう　見えてほしくない場所までカメラが映してしまう
現時点での動画との差異　Player - player_stand	test - Untitled		ファイルが種類別で表示されない

やること　カメラの移動範囲に制限をかけていく
ヒエラルキーMain Cameraを選択している状態で
インスペクターCameraー投影方法Projectionー透視Perspectiveから平行投影Orthographicに変更
↑画面を平面的に映すようになる　シーンビューの２Dボタンを押すと解りやすい

ヒエラルキーCM vcam1を選択した状態でインスペクターCinemachineVirtualCameraーLens  　
平行投影サイズ		Orthographic Size	5	←カメラの映す範囲を調整　		□大きさ
ニアクリップ面		Near Clip Plane	0.3	←どれだけ近くまでカメラに映すか		
ファークリップ面	Far Clip Plane		10	←どれだけ遠くまでカメラに映すか	

ヒエラルキーCM vcam1を選択した状態でインスペクターAdd Extension select▼ーCinemachine Confineをクリック
シネマシーンコンファインというコンポーネントが追加される

ヒエラルキーで右クリックー空のオブジェクトを作成（GameObject）名前：CameraCollider 　わかりやすいものに
インスペクターTransform…リセット　で位置をリセット
このゲームオブジェクトはカメラの移動範囲を表すのに使用する

コンポーネントを追加から🔍polygon collider 2d	2D ポリゴンコライダーPolygon Collider 2Dを追加

↑五角形のコライダーが出現　五角形では使いづらいので四角形にする
インスペクターPolygon Collider 2Dー▼ポイントー▼パスー▼要素0ーサイズ5→4に変更
ヒエラルキーCameraColliderから別のものを選択して再びCameraColliderを選択すると変な四角形になる

↑Polygon Collider 2Dのコライダーの編集Edit Colliderをクリックする  ←コライダーを動かせるようになるので□を広げていく
ウィンドウー２Dータイルパレットを選択してタイルパレットの位置を修正した
緑の四角の範囲がカメラが移動可能な範囲になる　白い四角より大きくなるようにする　（四角形じゃなくてもOK）

↑座標の数値を入れることで綺麗にすることができる　変な線ができたらヒエラルキーの別のゲームオブジェクト選択　元のゲームオブジェクト選択で消える
ヒエラルキーCameraColliderを選択した状態でインスペクターPolygon Collider 2D☑をオフ　←後で☑つけます
ヒエラルキーCM vcam1を選択した状態でインスペクターCinemachine Confiner (Script)ーBounding Shape 2Dに
ヒエラルキーCameraColliderオブジェクトをドラッグアンドドロップ
この状態で実行すると　カメラが範囲内しか動かないようになるが　ならない　うまくいかない　Unityのバージョンによるものと思われる
カメラが変な位置で固定された
ヒエラルキーCameraColliderオブジェクトを選択した状態でインスペクターPolygon Collider 2D☑をつける　トリガーするIs Trigger☑つける



＃４３	プログラムを整理しよう
Step13	今までのプログラムを整理しよう
Unity 2Dアクションの作り方【プログラムを整理しよう】【入門】 | ゲームの作り方！
覚えながら作るとぐちゃぐちゃになりやすい…　ぐちゃついたら定期的に整理整頓しよう

プレイヤーのスクリプトのインスペクターがたくさんあってわかりづらい
変数の前に[]をつける
Attribute　アトリビュート
クラスやメソッド、変数の前に　[属性]を書くと特殊な挙動になる　Unityの機能

//インスペクターで設定する
    public float speed; //速度
    public float jumpSpeed; //ジャンプ速度
    public float jumpHeight; //ジャンプする高さ
    public float jumpLimitTime; //ジャンプ制限時間
    public float gravity; //重力
    public GroundCheck ground; //接地判定
    public GroundCheck head; //頭をぶつけた判定
    public AnimationCurve dashCurve;
    public AnimationCurve jumpCurve;
↓
//インスペクターで設定する
[Header("移動速度")] public float speed;
[Header("重力")] public float gravity;
[Header("ジャンプ速度")] public float jumpSpeed;
[Header("ジャンプする高さ")] public float jumpHeight;
[Header("ジャンプ制限時間")] public float jumpLimitTime;
[Header("接地判定")] public GroundCheck ground;
[Header("頭をぶつけた判定")] public GroundCheck head;
[Header("ダッシュの速さ表現")] public AnimationCurve dashCurve;
[Header("ジャンプの速さ表現")] public AnimationCurve jumpCurve;
↑ヘッダーの属性を使う[Header(“コメント”)] 　全部のパブリックの変数に適用していく

↑変数に説明がつく

Next　FixedUpdate内に何でもかんでも書きすぎ　解りやすいように機能ごとにプログラムを分離していく
縦横の速度の決定を分離できそう
Y軸の速度を決定して返すメソッドを作成する
private float GetYSpeed()
    {

    }
↓FixedUpdate内にあるY軸に関係するプログラムを切り取り貼り付けする
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    [Header("移動速度")] public float speed;
    [Header("重力")] public float gravity;
    [Header("ジャンプ速度")] public float jumpSpeed;
    [Header("ジャンプする高さ")] public float jumpHeight;
    [Header("ジャンプ制限時間")] public float jumpLimitTime;
    [Header("接地判定")] public GroundCheck ground;
    [Header("頭をぶつけた判定")] public GroundCheck head;
    [Header("ダッシュの速さ表現")] public AnimationCurve dashCurve;
    [Header("ジャンプの速さ表現")] public AnimationCurve jumpCurve;

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isHead = false;
    private bool isJump = false;
    private float jumpPos = 0.0f;
    private float jumpTime = 0.0f;
    private float dashTime = 0.0f;
    private float beforeKey = 0.0f;

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();
        isHead = head.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float verticalKey = Input.GetAxis("Vertical");

        float xSpeed = 0.0f;
        float ySpeed = -gravity;

        if (isGround)
        {
            if(verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する
                isJump = true;
                jumpTime = 0.0f;
            }
            else
            {
                isJump = false;
            }
        }
        else if (isJump)
        {
            //上方向キーを押しているか
            bool pushUpKey = verticalKey > 0;
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + jumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか
            bool canTime = jumpLimitTime > jumpTime;

            if(pushUpKey && canHeight && canTime && !isHead)
            {
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;
            }
            else
            {
                isJump = false;
                jumpTime = 0.0f;
            }
        }

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            dashTime += Time.deltaTime;
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            dashTime += Time.deltaTime;
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            dashTime = 0.0f;
            xSpeed = 0.0f;
        }

        //前回の入力からダッシュの反転を判断して速度を変える
        if(horizontalKey > 0 && beforeKey < 0)
        {
            dashTime = 0.0f;
        }
        else if(horizontalKey < 0 && beforeKey > 0)
        {
            dashTime = 0.0f;
        }
        beforeKey = horizontalKey;

        //アニメーションカーブを速度に適用
        xSpeed *= dashCurve.Evaluate(dashTime);
        if(isJump)
        {
            ySpeed *= jumpCurve.Evaluate(jumpTime);
        }

        anim.SetBool("jump", isJump);
        anim.SetBool("ground", isGround);
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }

    private float GetYSpeed()
    {

    }
}
=====================

↓Y軸に関係するプログラムを移動させた
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    [Header("移動速度")] public float speed;
    [Header("重力")] public float gravity;
    [Header("ジャンプ速度")] public float jumpSpeed;
    [Header("ジャンプする高さ")] public float jumpHeight;
    [Header("ジャンプ制限時間")] public float jumpLimitTime;
    [Header("接地判定")] public GroundCheck ground;
    [Header("頭をぶつけた判定")] public GroundCheck head;
    [Header("ダッシュの速さ表現")] public AnimationCurve dashCurve;
    [Header("ジャンプの速さ表現")] public AnimationCurve jumpCurve;

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isHead = false;
    private bool isJump = false;
    private float jumpPos = 0.0f;
    private float jumpTime = 0.0f;
    private float dashTime = 0.0f;
    private float beforeKey = 0.0f;

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();
        isHead = head.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");
        float xSpeed = 0.0f;
       
        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);
            dashTime += Time.deltaTime;
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);
            dashTime += Time.deltaTime;
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);
            dashTime = 0.0f;
            xSpeed = 0.0f;
        }

        //前回の入力からダッシュの反転を判断して速度を変える
        if(horizontalKey > 0 && beforeKey < 0)
        {
            dashTime = 0.0f;
        }
        else if(horizontalKey < 0 && beforeKey > 0)
        {
            dashTime = 0.0f;
        }
        beforeKey = horizontalKey;

        //アニメーションカーブを速度に適用
        xSpeed *= dashCurve.Evaluate(dashTime);
        
        anim.SetBool("jump", isJump);
        anim.SetBool("ground", isGround);
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }

    private float GetYSpeed()
    {
	 float verticalKey = Input.GetAxis("Vertical");
	 float ySpeed = -gravity;

        if (isGround)
        {
            if(verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する
                isJump = true;
                jumpTime = 0.0f;
            }
            else
            {
                isJump = false;
            }
        }
        else if (isJump)
        {
            //上方向キーを押しているか
            bool pushUpKey = verticalKey > 0;
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + jumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか
            bool canTime = jumpLimitTime > jumpTime;

            if(pushUpKey && canHeight && canTime && !isHead)
            {
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;
            }
            else
            {
                isJump = false;
                jumpTime = 0.0f;
            }        
	}

	//アニメーションカーブを速度に適用
        if (isJump)
        {
              ySpeed *= jumpCurve.Evaluate(jumpTime);
        }
	
	return ySpeed;			//移動が完了したらリターンを返す
    }
}
=====================

作ったメソッド上で///スラッシュを3回書くと下記が出現
/// <summary>
///
/// </summary>
/// <returns></returns>
private float GetYSpeed()

<summary></summary>  の間に書いたコメントが呼び出す際に表示される

このメソッドについてのコメントを書いてみる
/// <summary>
/// Y成分で必要な計算をし、速度を返す
/// </summary>
/// <returns>Y軸の速さ</returns>

float ySpeed = GetYSpeed();　を追記
↑書いたメソッドをFixedUpdate内で呼び出してみる　書いたメソッドにカーソルを合わせると先ほど書いたコメントが表示されるようになる
チームで作るとコメントを入れることができてコードがわかりやすくなる

完成したもの
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    //インスペクターで設定する
    [Header("移動速度")] public float speed;
    [Header("重力")] public float gravity;
    [Header("ジャンプ速度")] public float jumpSpeed;
    [Header("ジャンプする高さ")] public float jumpHeight;
    [Header("ジャンプ制限時間")] public float jumpLimitTime;
    [Header("接地判定")] public GroundCheck ground;
    [Header("頭をぶつけた判定")] public GroundCheck head;
    [Header("ダッシュの速さ表現")] public AnimationCurve dashCurve;
    [Header("ジャンプの速さ表現")] public AnimationCurve jumpCurve;

    //プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isHead = false;
    private bool isJump = false;
    private float jumpPos = 0.0f;
    private float jumpTime = 0.0f;
    private float dashTime = 0.0f;
    private float beforeKey = 0.0f;

    // Start is called before the first frame update
    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        //接地判定を得る
        isGround = ground.IsGround();
        isHead = head.IsGround();

        //キー入力されたら行動する
        float horizontalKey = Input.GetAxis("Horizontal");

        float xSpeed = 0.0f;
        float ySpeed = GetYSpeed();

        if(horizontalKey > 0)
        {
            transform.localScale = new Vector3(1, 1, 1);
            anim.SetBool("run", true);			//次で差し替えられる

            dashTime += Time.deltaTime;
            xSpeed = speed;
        }
        else if(horizontalKey < 0)
        {
            transform.localScale = new Vector3(-1, 1, 1);
            anim.SetBool("run", true);			//次で差し替えられる
            dashTime += Time.deltaTime;
            xSpeed = -speed;
        }
        else
        {
            anim.SetBool("run", false);			//次で差し替えられる
            dashTime = 0.0f;
            xSpeed = 0.0f;
        }

        //前回の入力からダッシュの反転を判断して速度を変える
        if(horizontalKey > 0 && beforeKey < 0)
        {
            dashTime = 0.0f;
        }
        else if(horizontalKey < 0 && beforeKey > 0)
        {
            dashTime = 0.0f;
        }
        beforeKey = horizontalKey;

        //アニメーションカーブを速度に適用
        xSpeed *= dashCurve.Evaluate(dashTime);

        anim.SetBool("jump", isJump);		//次で移動する
        anim.SetBool("ground", isGround);		//次で移動する
        rb.velocity = new Vector2(xSpeed, ySpeed);
    }

    /// <summary>
    /// Y成分で必要な計算をし、速度を返す。
    /// </summary>
    /// <returns>Y軸の速さ</returns>
    private float GetYSpeed()
    {
        float verticalKey = Input.GetAxis("Vertical");
        float ySpeed = -gravity;

        if (isGround)
        {
            if (verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する
                isJump = true;
                jumpTime = 0.0f;
            }
            else
            {
                isJump = false;
            }
        }
        else if (isJump)
        {
            //上方向キーを押しているか
            bool pushUpKey = verticalKey > 0;
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + jumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか
            bool canTime = jumpLimitTime > jumpTime;

            if (pushUpKey && canHeight && canTime && !isHead)
            {
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;
            }
            else
            {
                isJump = false;
                jumpTime = 0.0f;
            }
        }

        if (isJump)
        {
            ySpeed *= jumpCurve.Evaluate(jumpTime);
        }
        return ySpeed;
    }
}
=====================

次は同じ用にX軸の速度をまとめてみる　ただしX軸のプログラムにアニメーションが混じっている　anim.SetBool(“run”, true); ←これを分解する

=====================
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
 public class Player : MonoBehaviour
 {
     #region//インスペクターで設定する					//⑭折りたたむ機能を追加
     [Header("移動速度")] public float speed;
     [Header("重力")] public float gravity;
     [Header("ジャンプ速度")] public float jumpSpeed;
     [Header("ジャンプする高さ")] public float jumpHeight;
     [Header("ジャンプする長さ")] public float jumpLimitTime;
     [Header("接地判定")] public GroundCheck ground;
     [Header("天井判定")] public GroundCheck head;
     [Header("ダッシュの速さ表現")] public AnimationCurve dashCurve;
     [Header("ジャンプの速さ表現")] public AnimationCurve jumpCurve;
     #endregion										//⑭折りたたむ機能を追加

     #region//プライベート変数							//⑭折りたたむ機能を追加

     private Animator anim = null;
     private Rigidbody2D rb = null;
     private bool isGround = false;
     private bool isJump = false;
     private bool isRun = false;							//①走っているかどうかのフラグを作成
     private bool isHead = false; 
     private float jumpPos = 0.0f;
     private float dashTime, jumpTime;
     private float beforeKey;
     #endregion										//⑭折りたたむ機能を追加

     void Start()
     {
          //コンポーネントのインスタンスを捕まえる
          anim = GetComponent<Animator>();
          rb = GetComponent<Rigidbody2D>();
     }

     void FixedUpdate()
     {
          //接地判定を得る
          isGround = ground.IsGround();
          isHead = head.IsGround(); 

          //各種座標軸の速度を求める
          float xSpeed = GetXSpeed();					//⑦FixedUpdateで呼び出す
          float ySpeed = GetYSpeed();					//各種メソッドに明確な役割を与えたのでこの中を変更すれば速度を変えられる

          //アニメーションを適用							//⑫FixedUpdateで呼び出す
          SetAnimation();								//各種メソッドに明確な役割を与えたのでこの中を変更すればアニメーションを変えられる

          //移動速度を設定								//⑬コメント記載
          rb.velocity = new Vector2(xSpeed, ySpeed);
     }

     /// <summary>
     /// Y成分で必要な計算をし、速度を返す。
     /// </summary>
     /// <returns>Y軸の速さ</returns>
     private float GetYSpeed()
     {
          float verticalKey = Input.GetAxis("Vertical");
          float ySpeed = -gravity;

          if (isGround)
          {
              if (verticalKey > 0)
              {
                  ySpeed = jumpSpeed;
                  jumpPos = transform.position.y; //ジャンプした位置を記録する
                  isJump = true;
                  jumpTime = 0.0f;
              }
              else
              {
                  isJump = false;
              }
          }
          else if (isJump)
          {
              //上方向キーを押しているか
　　　　　　　bool pushUpKey = verticalKey > 0;
　　　　　　　//現在の高さが飛べる高さより下か
　　　　　　　bool canHeight = jumpPos + jumpHeight > transform.position.y;
　　　　　　　//ジャンプ時間が長くなりすぎてないか
　　　　　　　bool canTime = jumpLimitTime > jumpTime;

　　　　　　　if (pushUpKey && canHeight && canTime && !isHead)
             {
                  ySpeed = jumpSpeed;
                  jumpTime += Time.deltaTime;
              }
              else
              {
                  isJump = false;
                  jumpTime = 0.0f;
              }
          }

          if (isJump)
          {
              ySpeed *= jumpCurve.Evaluate(jumpTime);
          }

          return ySpeed;
     }

     /// <summary>									//⑥サマリーでコメントを書く
     /// X成分で必要な計算をし、速度を返す。
     /// </summary>
     /// <returns>X軸の速さ</returns>
     private float GetXSpeed()							//②メソッドを作成する
     {
          float horizontalKey = Input.GetAxis("Horizontal");	//③X軸に関する処理を新しいメソッドに移動させる
          float xSpeed = 0.0f;

          if (horizontalKey > 0)
          {
              transform.localScale = new Vector3(1, 1, 1);
              isRun = true;								//④アニメーションの部分をフラグに差し替える
              dashTime += Time.deltaTime;
              xSpeed = speed;
          }
          else if (horizontalKey < 0)
          {
              transform.localScale = new Vector3(-1, 1, 1);
              isRun = true;								//④アニメーションの部分をフラグに差し替える
              dashTime += Time.deltaTime;
              xSpeed = -speed;
          }
          else
          {
              isRun = false;								//④アニメーションの部分をフラグに差し替える
              xSpeed = 0.0f;
              dashTime = 0.0f;
          }

          //前回の入力からダッシュの反転を判断して速度を変える
          if (horizontalKey > 0 && beforeKey < 0)
          {
              dashTime = 0.0f;
          }
          else if (horizontalKey < 0 && beforeKey > 0)
          {
              dashTime = 0.0f;
          }

          beforeKey = horizontalKey;
          xSpeed *= dashCurve.Evaluate(dashTime);
          beforeKey = horizontalKey;
          return xSpeed;								//⑤リターンで返す
     }

     /// <summary>									//⑪サマリーを書く
     /// アニメーションを設定する
     /// </summary>
     private void SetAnimation()						//⑧アニメーション用のメソッドを用意し
     {
          anim.SetBool("jump", isJump);					//⑨移動させる
          anim.SetBool("ground", isGround);
          anim.SetBool("run", isRun);						//⑩先程作成した走るフラグを書く
     }
 }
=====================
↑今後の処理の変更や追加がやりやすくなった
#region - #endregion ＃リージョン　＃エンドリージョン　の間に書かれたものを折りたたむ機能

後は今まで通り動けばOK



＃４４	敵を作ってみよう・その１
Step14	敵の当たり判定を作ってみよう
マリオのクリボーのような敵を作ってみよう
＜クリボーの特徴＞
・衝突するとプレイヤーはやられる　←今回はここ
・踏んづけるとプレイヤーはちょっと跳ねて敵はやられる
・画面内に入ると動き出す
・動いている間一定方向に動く
・壁に当たると判定側へ動く

下書きで適当に絵を書いていく　なぜ下書きにするか　＃３３　
歩き2コマ		enemy_walk1.png		enemy_walk2.png　
やられた1コマ　enemy_dead.png
合計3コマ

iPadのProcreateで作成でぴよった　 画像を作成してUnityに入れたら背景が黒いがテクスチャタイプを２Dにして　適応すれば浸透化される
敵画像３つをUnityのプロジェクトAssetsーTexture配下に配置する
敵画像３つを選択した状態でインスペクターのテクスチャータイプースプライト(2DとUI)に変更後、適用するを押下　←すると浸透化される
enemy_walk1をシーン上(Untitled配下)にドラッグアンドドロップする

↑enemy_walk1を選択した状態でインスペクターコンポーネントを追加からBox Collider 2Dを追加
↓角がつっかえるので少し大きさを小さくしてエッジの半径Edge Radiusを0.14とすると角が丸くなる　後は敵に合わせてコライダーを調整する

もし、複雑な形の敵だったら？
Colliderの性質として親にRigidbodyやリジッドボディ2Dがある場合、子オブジェクトも同一の物体として扱う　ただし子オブジェクトにリジッドボディがついていない場合
子オブジェクトにリジッドボディがついていると別の物体として扱われる　＃１２物理演算について

空のオブジェクト作成
コンポーネントの追加
🔍CircleCollider2D		2D サークルコライダー
🔍CapsuleCollider2D	2D カプセルコライダー
🔍Box Collider 2D		2D ボックスコライダーを含めこの３つが基本的なコライダーとなる　コライダーは同一の物体であれば重ねてもOK　コライダーを重ねてもいけばいろいろな形にできる
子オブジェクトでなくても親にコライダーをつけることもできるがゲットコンポーネントなどでコライダーを取得した時、どれを取得したか分からなくなってしまうので
オブジェクトを分けておくと安全

編集できるコライダーもある
🔍PolygonCollider2D	2D ポリゴンコライダー　	これは以前登場したやつ
🔍EdgeCollider2D		2D エッジコライダー		線で当たり判定を編集することができる　編集方法はポリゴンコライダー２Dと同じ
様々なコライダーがあるので複雑な敵を作ってもいけそう　コライダーをつけすぎると重くなるので付け過ぎには注意　ある程度全体を覆えれば大丈夫
さっき作った空のオブジェクトを削除
ずっと気になっていた名前を変更　 - player_stand　→Player	 - Untitled　→test　←プロジェクトシーンズ　対象右クリックで名前変更できた
現時点での動画との差異　		ファイルが種類別で表示されない

敵の当たり判定ができたら今度はその当たり判定を判別できるようにする
ヒエラルキーenemy_walk1を選択した状態でインスペクターのタグTag Untagged▼ータグを追加Add Tag… 
＋ー名前：Enemy  的だと解る名前にする　後は敵のゲームオブジェクトの名前を変更する　
ヒエラルキーenemy_walk1を選択した状態でインスペクターのタグTag Untagged▼ーEnemy 　※子オブジェクトもTagの変更が必要　子オブジェクトは作成していない
当たり判定に関するのことはできたので敵に物理演算を付与していく
インスペクターコンポーネントを追加からRigidbody2Dを追加　Rigidbody 2D ▼Constraints回転を固定Freeze Rotation☑Z　←回転しないように

プレイヤーのスクリプトを開く

プライベート変数の一番最後に書く
=====================
#region//プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isJump = false;
    private bool isRun = false;
    private bool isHead = false;
    private float jumpPos = 0.0f;
    private float dashTime, jumpTime;
    private float beforeKey;
    private string enemyTag = "Enemy";					//①先程のタグと同じ文字列を定義しておく
    #endregion
=====================
スクリプトの一番最後に追記
=====================
#region//接触判定									//⑤＋を付ける
    private void OnCollisionEnter2D(Collision2D collision)	//②オンコリジョンエンター２Dというメソッドを追加
    {
        if(collision.collider.tag == enemyTag)				//③③
        {
            Debug.Log("敵と接触した");						//④ログを出して確認
        }
    }
    #endregion										//⑤＋を付ける
=====================
↑メソッド名を一字一句間違えないようにする
<OnCollisionEnter2D> Unity側が呼ぶ特別なメソッド　物体が衝突した時に呼ばれる　接触判定の時のOnTriggerEnter2Dとは違う
OnTriggerEnter2Dでは引数が侵入してきた当たり判定のコライダーだったがOnCollisionEnter2Dでは衝突データが入っている
③衝突データから衝突相手を取得する　←衝突してきた相手のコライダーを取得　③コライダータグがEnemyだった場合、敵と衝突したとみなす

↑この状態で実行▶するとカエルちゃんがはっちゃんに当たると敵と衝突したログが出る

やること　接触判定が取れたので敵と接触したらプレイヤーがやられるようにしていく
プレイヤーのアニメーターウィンドウを開く　プレイヤーがダウンするアニメーションの名前を確認　player_down　アニメーションについて　＃３４

プレイヤーのスクリプトを開く
=====================
#region//プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private bool isGround = false;
    private bool isJump = false;
    private bool isRun = false;
    private bool isHead = false;
    private bool isDown = false;			//①ダウン用のフラグを用意
    private float jumpPos = 0.0f;
    private float dashTime, jumpTime;
    private float beforeKey;
    private string enemyTag = "Enemy";
    #endregion
=====================
↓そしてダウン中に動かないようにする
=====================
void FixedUpdate()
    {
        if (!isDown)							//②ダウンフラグがfalseの時のみ処理を行うようにする
        {
            //接地判定を得る
            isGround = ground.IsGround();
            isHead = head.IsGround();

            //各種座標軸の速度を求める
            float xSpeed = GetXSpeed();
            float ySpeed = GetYSpeed();

            //アニメーションを適用
            SetAnimation();

            //移動速度を設定
            rb.velocity = new Vector2(xSpeed, ySpeed);
        }
        else
        {
            rb.velocity = new Vector2(0, -gravity);	//③ダウン中は重力のみ適用　落下する以外の行動が出来なくなる
        }
    }
=====================
↓敵と接触した際　ダウンするようにしていく
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            anim.Play("player_down");				//④アニメーションを直接再生する
            isDown = true;						//⑤ダウンフラグをtrueにする
        }
    }
    #endregion
=====================
Animator.Play(“ステート名”)　ステート名で指定したアニメーションを矢印キーなどを無視して直接再生する

↑ステート名　アニメーション名とは違う　デフォルトだとアニメーション名と同じとなる　アニメーション名とは別物
プロジェクトAssetsーAnimationーplayer_downを選択した状態でインスペクターのループ時間☑を外す　最初から外れていたが
再生すると　アニメーションが一つ多かったので　４つから３つに変更した　ダウンアニメーションは用意したアニメーションだけで良い

↓この状態で実行▶すると敵にぶつかった時、ちゃんとダウンするようになる




＃４５	敵を作ってみよう・その２
Step15	衝突判定を切り分けてみよう

マリオのクリボーのような敵を作ってみよう
＜クリボーの特徴＞
・衝突するとプレイヤーはやられる　
・踏んづけるとプレイヤーはちょっと跳ねる　←今回はここ
・踏んづけると敵はやられる
・画面内に入ると動き出す
・動いている間一定方向に動く
・壁に当たると判定側へ動く

今のままでは踏んづけてもプレイヤーがやられてしまう　踏んづけた時はやられないようにしてちょっと跳ねるようにしてみる
踏んだ時跳ねるのは敵以外にも作りそうなので一工夫する　新たに衝突用のスクリプトを用意する
プロジェクトAssetsーScript右クリックー作成ーC#スクリプト　名前：ObjectCollision  スクリプトをダブルクリック　バーチャルスタジオで開く

void Start()とvoid Update()を削除する
↓新しく作成したオブジェクトコリジョンのスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ObjectCollision : MonoBehaviour
{
    [Header("これを踏んだ時のプレイヤーが跳ねる高さ")] public float boundHeight;		//①プレイヤーが踏んだ時に設定するパラメーター　跳ねる高さ

    /// <summary>								//③サマリーを書く　②を書いてからじゃないと出現しない
    /// このオブジェクトをプレイヤーが踏んだかどうか
    /// </summary>
    [HideInInspector] public bool playerStepOn;		//②プレイヤーがこのオブジェクトを踏んだかどうかのフラグだけ持たせておく④ハイドインスペクターにする
}
=====================
↑スクリプトどう使うか：踏んづけたら跳ねるものにくっつけて使う　クリボーなど　役割：プレイヤーと踏んづけられた物の橋渡しをする
1　プレイヤーが何かを踏んづけた時にこのスクリプトが貼りついてきたら
2　跳ねる高さを取得し
3　踏んづけた側に　踏んづけたことを通知する

もっとスマートな方法もあるが今回は初心者向けで書いている
他のスクリプトから読めるようにpublicにしているが
public float boundHeight　	←インスペクターで編集してほしいパラメーター
public bool playerStepOn	←インスペクターで編集してほしくないパラメーター　踏んづけられたかどうかを編集できてしまったらおかしいから
↑アトリビュートのハイドインスペクターを使う
＜Attribute : HideInspector＞インスペクターにシリアライズ化されたものが表示されなくなるアトリビュート　
ただ単にインスペクターで表示されなくなるだけ　シリアライズ化はされている

オブジェクトコリジョンのスクリプトを敵に貼り付ける
ヒエラルキーenemy_walk1を選択した状態でObjectCollisionスクリプトをコンポーネントを追加へドラッグアンドドロップ

↑ヒエラルキーで踏んづけたかどうかのパラメーターは表示されていない

やること　プレイヤーの衝突に踏んづけたかどうかの判定をつける

プレイヤーのスクリプトを編集する　
Player.cs
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            foreach(ContactPoint2D p in collision.contacts)	//①
            {

            }

            anim.Play("player_down");
            isDown = true;
        }
    }
    #endregion
=====================
今回もCollision2Dは衝突データが入る
衝突地点の詳細データ
衝突地点のデータが配列　配列について　＃２２
何故　衝突地点のデータが配列か

↑もしこんな感じの敵を作った場合　複数衝突する可能性がある　複数なので配列　この場合プレイヤーはやられるべき　一箇所でもマズイ当たり方をしたらアウト
コアエーチでループさせて配列の中身を全て調べる必要がある
この中に一カ所でもマズイ位置で当たった（マズイデータ）らプレイヤーは、やられる必要がある
Player.cs
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            foreach(ContactPoint2D p in collision.contacts)
            {
                if (敵と衝突した位置が足元だったら)
                {
                    //もう一度跳ねる
                }
                else
                {
                    //ダウンする
                    anim.Play("player_down");
                    isDown = true;
                }
            }
        }
    }
    #endregion
=====================
↑衝突した位置によって判定を切り分けていく　敵と衝突した位置が足元だったらもう一度跳ねて、それ以外だったらダウンするようにする

衝突した位置が足元だったかどうかをどう判別するのか考えよう
Player.cs
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            foreach(ContactPoint2D p in collision.contacts)
            {
                p.point ←このデータの衝突した位置
                    これを使って足元だったらという条件を満たすには？

                if (p.point.y < transform.position.y) //衝突した位置が自分の中心位置くらい
                {
                    //もう一度跳ねる
                }
                else
                {
                    //ダウンする
                    anim.Play("player_down");
                    isDown = true;
                }
            }
        }
    }
    #endregion
=====================
衝突した位置のY座標が　＜　自分のY座標

↑しかしながらtransform.positionというのはデフォルトではスプライトの真ん中を指している
この位置のY座標より下とした場合　キャラクターの真ん中から下の範囲が足元ということになってしまう
ということはキャラクターより半分以下の大きさの敵は当たったとしても踏んづけた判定となってしまう

ちゃんと計算できるように情報を持ってくる

Player.cs
=====================
#region//プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private CapsuleCollider2D capcol = null;				//①カプセルコライダー２Dの変数を用意して
    private bool isGround = false;
    private bool isJump = false;
    private bool isRun = false;
    private bool isHead = false;
    private bool isDown = false;
    private float jumpPos = 0.0f;
    private float dashTime, jumpTime;
    private float beforeKey;
    private string enemyTag = "Enemy";
    #endregion

    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
        capcol = GetComponent<CapsuleCollider2D>();		//②スタートでインスタンスを捕まえる　プレイヤーのコライダー
    }
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            foreach(ContactPoint2D p in collision.contacts)
            {
                p.point ←衝突した位置
                    足元だったらという条件を満たすには？

                if (p.point.y < transform.position.y - (capcol.size.y / 2f)) 	//③先程の条件からプレイヤーのコライダーのサイズの半分を切り取る
                {
                    //もう一度跳ねる
                }
                else
                {
                    //ダウンする
                    anim.Play("player_down");
                    isDown = true;
                }
            }
        }
    }
    #endregion
=====================

↑プレイヤーの中心位置からプレイヤーのコライダーのYのサイズつまり高さの半分の大きさを引くのでココより下で踏んづけた場合となる

↑これもちょっとまずい…　さらに計算するためのパラメーターを増やす
Player.cs
=====================
#region//インスペクターで設定する
    [Header("移動速度")] public float speed;
    [Header("重力")] public float gravity;
    [Header("ジャンプ速度")] public float jumpSpeed;
    [Header("ジャンプする高さ")] public float jumpHeight;
    [Header("ジャンプする長さ")] public float jumpLimitTime;
    [Header("踏みつけ判定の高さの割合")] public float stepOnRate;
    [Header("接地判定")] public GroundCheck ground;
    [Header("天井判定")] public GroundCheck head;
    [Header("ダッシュの速さ表現")] public AnimationCurve dashCurve;
    [Header("ジャンプの速さ表現")] public AnimationCurve jumpCurve;
    #endregion
=====================
①踏みつけ判定の高さの割合をインスペクターで調整できるようにする
先程の調整用のパラメーターを駆使して計算を行う
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            foreach(ContactPoint2D p in collision.contacts)
            {
                //踏みつけ判定になる高さ
                float stepOnHeight = (capcol.size.y * (stepOnRate / 100f));

                //踏みつけ判定のワールド座標
                float judgePos = transform.position.y - (capcol.size.y / 2f) + stepOnHeight;

                if (p.point.y < judgePos) 
                {
                    //もう一度跳ねる
                }
                else
                {
                    //ダウンする
                    anim.Play("player_down");
                    isDown = true;
                }
            }
        }
    }
    #endregion
=====================
②プレイヤーの高さに割合をかけることによってプレイヤーの高さの指定％までが踏みつけ判定になるようにする
これで踏みつけ判定の高さをインスペクターで調整できるようになる
（例）インスペクターで１０と設定するとこの変数の大きさはプレイヤーの高さの１０％ということになる
③ここからどの地点が踏みつけ判定になるのかを求めていく　ここまではさっきと一緒　これに先程の高さを足す
↓先程の高さをインスペクターで１０にした場合ココより下となる　コレでうまくいきそう

インスペクター１０は　どれくらいのたかさにするかはキャラクターによるので各自調整しろ
④p.point.y 　ループ分の中でしか使えないのはコレだけ　なので　他の計算はループの外にもっていく
ループの中で同じ計算を何回もするのは無駄になってしまうから

Player.cs
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            //踏みつけ判定になる高さ
            float stepOnHeight = (capcol.size.y * (stepOnRate / 100f));

            //踏みつけ判定のワールド座標
            float judgePos = transform.position.y - (capcol.size.y / 2f) + stepOnHeight;

            foreach (ContactPoint2D p in collision.contacts)
            {
                if (p.point.y < judgePos) 
                {
                    //もう一度跳ねる
                }
                else
                {
                    //ダウンする
                    anim.Play("player_down");
                    isDown = true;
                }
            }
        }
    }
    #endregion
 } 
=====================
↑これで踏みつけ判定の部分ができた
最後の } が一つ抜けていたのでエラーとなった　付けたら直った 　public class Player : MonoBehaviourの｛　の相方

やること　ちょっと跳ねる部分を作成

Player.cs
=====================
#region//プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private CapsuleCollider2D capcol = null;
    private bool isGround = false;
    private bool isJump = false;
    private bool isRun = false;
    private bool isHead = false;
    private bool isDown = false;
    private bool isOtherJump = false;
    private float jumpPos = 0.0f;
    private float otherJumpHeight = 0.0f;
    private float dashTime, jumpTime;
    private float beforeKey;
    private string enemyTag = "Enemy";
    #endregion
=====================
①何かを踏んだ時のジャンプは通常のジャンプとは違うので別のフラグとパラメーターを用意する
次に跳ねている時の処理を書いていく　ジャンプの処理とほとんど一緒なのでジャンプの処理をコピーしてくる
注意点：跳ねる処理は地面にいる時の処理より上にする　地面についた状態で動いてきた敵を踏んづける可能性があるため


=====================
/// <summary>
    /// Y成分で必要な計算をし、速度を返す。
    /// </summary>
    /// <returns>Y軸の速さ</returns>
    private float GetYSpeed()
    {
        float verticalKey = Input.GetAxis("Vertical");
        float ySpeed = -gravity;

        //ジャンプ中
        if (isOtherJump)	//②else if →if 　　　else if→ if		//③跳ねる処理用に変更する　上方向キーを消す
        {
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + otherJumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか
            bool canTime = jumpLimitTime > jumpTime;

            if (canHeight && canTime && !isHead)
            {
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;
            }
            else
            {
                isOtherJump = false;
                jumpTime = 0.0f;
            }
        }
        //地面にいるとき
        else if (isGround)	//②if →else if 
        {
            if (verticalKey > 0)
            {
                ySpeed = jumpSpeed;
                jumpPos = transform.position.y; //ジャンプした位置を記録する
                isJump = true;
                jumpTime = 0.0f;
            }
            else
            {
                isJump = false;
            }
        }
        //ジャンプ中
        else if (isJump)
        {
            //上方向キーを押しているか
            bool pushUpKey = verticalKey > 0;
            //現在の高さが飛べる高さより下か
            bool canHeight = jumpPos + jumpHeight > transform.position.y;
            //ジャンプ時間が長くなりすぎてないか
            bool canTime = jumpLimitTime > jumpTime;

            if (pushUpKey && canHeight && canTime && !isHead)
            {
                ySpeed = jumpSpeed;
                jumpTime += Time.deltaTime;
            }
            else
            {
                isJump = false;
                jumpTime = 0.0f;
            }
        }
        
        if (isJump || isOtherJump)					//④ジャンプの速度設定を跳ねているときにも適用する
        {
            ySpeed *= jumpCurve.Evaluate(jumpTime);
        }
        return ySpeed;
    }
=====================
これで跳ねる処理の部分は完成

やること　踏んづけた相手からどれくらい高く跳ねるのかを取得

Player.cs
=====================
#region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            //踏みつけ判定になる高さ
            float stepOnHeight = (capcol.size.y * (stepOnRate / 100f));

            //踏みつけ判定のワールド座標
            float judgePos = transform.position.y - (capcol.size.y / 2f) + stepOnHeight;

            foreach (ContactPoint2D p in collision.contacts)
            {
                if (p.point.y < judgePos)
                {
                    //もう一度跳ねる
                    ObjectCollision o = collision.gameObject.GetComponent<ObjectCollision>();　//①
                    if(o != null)
                    {
                        otherJumpHeight = o.boundHeight;		//②踏んづけたものから跳ねる高さを取得する
                        o.playerStepOn = true;          				//②踏んづけたものに対して踏んづけた事を通知する
                        jumpPos = transform.position.y; 			//②ジャンプした位置を記録する
                        isOtherJump = true;						//③各種フラグをセットする
                        isJump = false;							//③各種フラグをセットする
                        jumpTime = 0.0f;						//③各種フラグをセットする
                    }
                    else
                    {
                        Debug.Log("ObjectCollisionが付いてないよ！");
                    }
                }
                else
                {
                    //ダウンする
                    anim.Play("player_down");
                    isDown = true;
                    break;
                }
            }
        }
    }
    #endregion
=====================
敵との衝突判定のところに処理を書き足していく
①衝突したオブジェクトから冒頭で作った橋渡しをしているスクリプトを取得します
橋渡しをしているスクリプトにどれくらいの高さで跳ねるかのパラメーターがあるので、それをとってくれば跳ねる処理に渡すことができる
ObjectCollisionから跳ねる高さを取得

複雑な形の敵を作るときはコライダーを子オブジェクトにしたほうが良い　と前回解説
衝突したコライダーのゲームオブジェクトからコンポーネントを取得している
コライダーが付いている全ての子オブジェクトに橋渡しをしているスクリプトを貼り付けないといけない？　答えはNo
collision.gameObjectはRigidbody2Dがついているゲームオブジェクト　コレに一つだけつけておけばOK

 ObjectCollisionはループの外に出すべきでは？
スクリプトが必要になるのは足元で踏んづけた時のみ必要で足元で複数箇所衝突する可能性が低い為ループの中に入れてある

↑このような時はOnCollisionEnter2Dが２回呼ばれる

 //もう一度跳ねる
 ObjectCollision o = collision.gameObject.GetComponent<ObjectCollision>();　
				 ↑
				 一つの敵から足元で複数箇所接触した場合にのみ何回も呼ばれる　踏んづけた時しか処理しないのでココに書いてある
 o.playerStepOn = true;	 //踏んづけたものに対して踏んづけた事を通知する
			       ↑
			       ループの中にあっても問題ない

break;　←ダウンが一回でもあった場合ループする意味がなくなるので　ブレイクでダウン時はループを抜ける

やること　跳ねた時もう一度ジャンプアニメーションするように設定する

Player.cs
=====================
private void SetAnimation()
    {
        anim.SetBool("jump", isJump || isOtherJump);   //①アニメーションのジャンプを跳ねた時にもtrueになるようにする
        anim.SetBool("ground", isGround);
        anim.SetBool("run", isRun);
    }
=====================

ヒエラルキーplayerを選択、アニメーターウィンドウのplayer_jump_down右クリックー遷移を作成Make Transition↑player_jump_up
(ジャンプ下降モーションからジャンプ上昇モーションへ矢印をつなぐ)
作成した矢印↑を選択した状態で終了時間ありHas Exit Time☑を外す
▼Settingsをクリックー遷移間隔(s)Transition Duratiorを0.25→0
Conditions リストは空です　＋を押下　条件を　jump trueにする　(ジャンプフラグがtrueの場合という意味)
↓最後に各種　インスペクターの設定を忘れずに
playerの踏みつけ判定の高さの割合を10にする
enemy_walk1を選択した状態でインスペクターのこれを踏んだ時のプレイヤーが跳ねる高さを3にする
この状態で実行▶すると　踏んだ時跳ねて　横から当たった時ちゃんとダウンするようになる



＃４６	敵を作ってみよう・その３
Step16	敵の挙動を作成してみよう

マリオのクリボーのような敵を作ってみよう
＜クリボーの特徴＞
・衝突するとプレイヤーはやられる　
・踏んづけるとプレイヤーはちょっと跳ねる　
・踏んづけると敵はやられる	←今回はここ
・画面内に入ると動き出す		←今回はここ
・動いている間一定方向に動く	←今回はここ
・壁に当たると判定側へ動く	←今回はここ

やること　敵用のスクリプトを作成　　今回は初心者用として簡単な方法で作成していく
プロジェクトーAssetsーScript右クリック作成ーC#スクリプトー名前：Enemy_Zako1
エネミーザコ１スクリプトをビジュアルスタジオで開く　画面内に入ったら動き出すを作成する

ヒエラルキーGridを選択した状態でウィンドウー２Dータイルパレットで地面を増やした　はっちゃんとカエルちゃんの距離をはなした

↑ヒエラルキーCameraColliderを選択した状態でインスペクターの要素0　X15→30　要素3　X15→30に変更した


C#スクリプトー名前：Enemy_Zako1
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy_Zako1 : MonoBehaviour
{
    private SpriteRenderer sr = null;				//①スプライトレンダラー型の変数を用意して

    // Start is called before the first frame update
    void Start()
    {
        sr = GetComponent<SpriteRenderer>();    	//②スタート内でゲットコンポーネントしてインスタンスを捕まえます
    }

    // Update is called once per frame
    void Update()
    {
        if (sr.isVisible)							//③スプライトレンダラー.isビシブルと書く
        {
            Debug.Log("画面に見えている");			//④これが正しく機能しているか確認
        }    
    }
}
=====================
↓スプライトレンダラー　画面にスプライトを表示させているコンポーネント　キャラクターを表示させている

③〇〇Renderer.isVisibleとは画面内にそのオブジェクトが表示されていかを返すパラメータ　※SceneViewも含む
Unityの機能で実装されている名前にレンダラーがつくものは基本的にこのパラメータを持っている
ただしシーンビューで表示されていてもtrueで返ってくるので気をつける　シーンビューとゲームビューを同時に表示しているとゲーム内の挙動が通常と違う形になる

ヒエラルキーenemy_walk1を選択した状態でEnemy_Zako1スクリプトをコンポーネントの追加へドラッグアンドドロップしてスクリプトを貼り付ける
この状態で実行▶すると敵が画面に表示された時、画面に見えているとログが表示される　画面外に出るとログが表示されなくなり　表示されている時だけtrueとなる

C#スクリプトー名前：Enemy_Zako1
=====================
public class Enemy_Zako1 : MonoBehaviour
{
    [Header("画面外でも行動するか")] public bool nonVisible;

    private SpriteRenderer sr = null;

    // Start is called before the first frame update
    void Start()
    {
        sr = GetComponent<SpriteRenderer>();    
    }

    // Update is called once per frame
    void Update()
    {
        if (sr.isVisible || nonVisible)
        {
            //行動する
        }    
    }
}
=====================
↑敵キャラクターを画面外でも行動させたい場合もあると思うのでインスペクターから設定できるようにしておく

やること　移動を作成

C#スクリプトー名前：Enemy_Zako1
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy_Zako1 : MonoBehaviour
{
    #region//インスペクターで設定する						//①隠せるようにする　コメント書く
    [Header("移動速度")] public float speed;					//②移動速度のパラメータを用意
    [Header("重力")] public float gravity;						//③呪力のパラメータを用意
    [Header("画面外でも行動するか")] public bool nonVisible;
    #endregion											//①隠すエンド

    #region//プライベート変数								//④隠せるようにする　コメント書く
    private Rigidbody2D rb = null;							//⑤プレイヤーの時と同じようにリジッドボディ２Dで動かすのでそのインスタンスを捕まえる　変数
    private SpriteRenderer sr = null;
    private bool rightTleftF = false;							//⑥右向き左向きのフラグを作成
    #endregion											//④隠すエンド

    // Start is called before the first frame update
    void Start()
    {
        sr = GetComponent<SpriteRenderer>();
        rb = GetComponent<Rigidbody2D>();					//⑦リジッドボディ２Dをゲットコンポーネントする
    }

    // Update is called once per frame
    void FixedUpdate()									//⑩アップデートをフィックスドアップデートに変更　＃３９参照
    {
        if (sr.isVisible || nonVisible)
        {
            int xVector = -1;									//進む方向を決めて移動させる
            if (rightTleftF)									//⑧右向き左向きのフラグから
            {
                xVector = 1;									//進む方向を決めて移動させる
                transform.localScale = new Vector3(-1, 1, 1);			//敵の向きと　左右の反転はコライダーも反転する
            }
            else
            {
                transform.localScale = new Vector3(1, 1, 1);			//敵の向きと　左右の反転はコライダーも反転する
            }
            rb.velocity = new Vector2(xVector * speed, -gravity);
        }
        else												//⑨画面に写っていない間、スリープ状態にする
        {
            rb.Sleep();
        }
    }
}
=====================
複雑な形のコライダーを設定した場合、オブジェクトを駆使して一番親が横幅の真ん中にくるように設定する
Rigidbody2D.Sleep()とはそのオブジェクトを一時的に物理演算から外すもの
画面に写っていない時、物理演算が働かないので負荷軽減になる
スリープは起こさないといけないのでは？　←動かすと勝手に起きる　 rb.velocity = new Vector2(xVector * speed, -gravity);　何かにぶつかっても勝手に起きる

Enemy_Zako1のインスペクターの　移動速度　重力を3に設定する
この状態で実行▶すると敵が画面内に入った時にちゃんと移動する

やること　アニメーションを作成
プロジェクトAssetsーAnimation右クリックー作成ーアニメーターコントローラー　名前：enemy_zako1 
アニメーションについて　＃３４

ヒエラルキーenemy_walk1を選択した状態でenemy_zako1 をインスペクターAnimatorのControllerコントローラーへドラッグアンドドロップ
これでキャラクターにアニメーションを付ける下準備ができた
Unity上のタブ　ウィンドウーアニメーションーアニメーションを選択　アニメーションウィンドウが開く
ヒエラルキーのキャラクターenemy_walk1を選択した状態でアニメーションウィンドウのCreate作成を押下  ←アニメーションファイル新規作成
作成するアニメーション名で保存　enemy_zako1_dead.anim（１つ）		enemy_zako1_walk.anim（３つ）			save

↑デフォルトから名前をwalk とdeadに変更
この状態で実行▶すると敵が歩く

やること　踏まれたらやられる


C#スクリプトー名前：Enemy_Zako1
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy_Zako1 : MonoBehaviour
{
    #region//インスペクターで設定する
    [Header("移動速度")] public float speed;
    [Header("重力")] public float gravity;
    [Header("画面外でも行動するか")] public bool nonVisible;
    #endregion

    #region//プライベート変数
    private Rigidbody2D rb = null;
    private SpriteRenderer sr = null;
    private Animator anim = null;						//①やられたモーションを再生する為　アニメーターを
    private ObjectCollision oc = null;					//②橋渡をするスクリプト
    private BoxCollider2D col = null;						//③２Dコライダーの変数
    private bool rightTleftF = false;
    private bool isDead = false;						//④
    #endregion

    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();				//上に合わせて
        sr = GetComponent<SpriteRenderer>();				//順番を入れ替えた
        anim = GetComponent<Animator>();				//⑤ゲットコンポーネント
        oc = GetComponent<ObjectCollision>();			//⑥
        col = GetComponent<BoxCollider2D>();			//⑦
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        if (!oc.playerStepOn)							//⑧橋渡しするスクリプトからプレイヤーに踏まれたかどうか
        {
        
            if (sr.isVisible || nonVisible)
            {
                int xVector = -1;
                if (rightTleftF)
                {
                    xVector = 1;
                    transform.localScale = new Vector3(-1, 1, 1);
                }
                else
                {
                    transform.localScale = new Vector3(1, 1, 1);
                }
                rb.velocity = new Vector2(xVector * speed, -gravity);
            }
            else
            {
                rb.Sleep();
            }
        }											//⑨踏まれた時の処理
        else											//
        {
            if(!isDead)									//フラグを一回しか通らないように
            {
                anim.Play("dead");							//敵は踏まれた時　下に落ちていく形にして当たり判定を消す
                rb.velocity = new Vector2(0, -gravity);
                isDead = true;
                col.enabled = false;
            }
        }
    }
}
=====================
(特定の)コンポーネント.enabledというのは　そのコンポーネントが有効かどうかを表す		col.enabled = false;
↑インスペクターで見た時、☑チェックマークがあるもの　☑Box Collider 2Dなど　←イネーブルドを使用できる　☑がないものは使用できない
col.enabled = false;←Box Collider 2Dを無効にしている

子オブジェクトにコライダーを持たせている場合は次のようにする
先ずコライダーを持たせている子オブジェクトを空のゲームオブジェクト（ColliderObj）を追加してその子にする

C#スクリプトー名前：Enemy_Zako1
=====================
 if(!isDead)								
            {
                anim.Play("dead");							
                rb.velocity = new Vector2(0, -gravity);
                isDead = true;
                col.enabled = false;
		Transform t = transform.Find(“ColliderObj”);		←追加
		if (t != null)								←
		{										←
			t.gameObject.SetActive(false);			←
		}										←
            }
=====================
↑スクリプトにトランスフォームでFindしてコライダーをまとめたゲームオブジェクトを非アクティブにする処理を追加する
これで子オブジェクトについていたコライダーをまとめて無効にできる
Transform.Find(“名前”)というのはそのゲームオブジェクトの子オブジェクトから指定した名前のゲームオブジェクトを取得するメソッド
ただし返り値はゲームオブジェクトではなくトランスフォームなので注意
以前紹介したGameObject.Find(“名前”)とは違うものになる

・GameObject.Find　シーン上にある全てのゲームオブジェクトを検索して名前が一致したゲームオブジェクトを取得する
使い方としてはGameObject.Find(“名前”);と書けばOK
			↑クラスから直接メソッドを呼び出している　クラスに直接アクセスして扱えるメソッドをスタティックメソッドと言う　※アクティブでないと取得できない

・Transform.Find　このインスタンスがついているゲームオブジェクトの子オブジェクトから名前が一致したゲームオブジェクトのTransformを返すものになる
使い方GameObject.Findとは違いインスタンスからアクセスする　transform.Find(“名前”);
													↑インスタンスが入っている変数
GameObject.Findは大文字でしたがtransform.Findは小文字　※非アクティブでも取得可能
これら２つは似ているが使い方がまったく違うので注意

ちょっとした演出を追加
C#スクリプトー名前：Enemy_Zako1
=====================
if(!isDead)
            {
                anim.Play("dead");
                rb.velocity = new Vector2(0, -gravity);
                isDead = true;
                col.enabled = false;
                Destroy(gameObject, 3f);				//②やられた時の処理で３秒後にこのゲームオブジェクトを削除する
            }
            else									//やられる際の処理が終わったら
            {
                transform.Rotate(new Vector3(0, 0, 5));		//①ゲームオブジェクトを３秒間くるくる回転させるメソッド
            }
=====================
①Transform.Rotateとはゲームオブジェクトを回転させるメソッド　このスプリクトの場合、Transfomのローテーションを５増やすという効果がある

この場合、FixedUpdateに書かれているのでくるくる回る
物理演算で動いているものをトランスフォームで操作すると再計算が走って重くなるのでしたよね　col.enabled = false;でコライダーを切っているので問題ない
コライダーが切られてしまって物理演算での重い処理が走らなくなったのでトランスフォームで操作しても問題ない

②Destroy(オブジェクト,時間)とは指定したオブジェクトを削除するメソッド　※時間指定があれば待つ
ゲームオブジェクトも削除できるしコンポーネントのみを削除することもできる　オブジェクト指定の後、時間を書くとその秒数後に削除を実行する
この時間指定は書いても書かなくてもいい　書かない場合は即座に削除される

この状態で実行すると敵がやられた時くるくる回って落ちるようになる　しかしながら敵がやられた時タイルマップの裏側に入ってしまう場合がある
今起きていなくてもPCを再起動させたりするとなったりする場合がある　Z軸を変えれば直るはずが　直らないケースがある　バグ？　なのでレイヤー分けします

ヒエラルキーTilemapを選択した状態で
インスペクターTilemap Rendererー▼追加設定Additional SettingsーソートレイヤーSorting LayerーDefault▼ Add Sorting Layerを押下
▼ソートレイヤーSorting Layers＋ー名前：TileMapを追加し順番を一番上にもってくる
ヒエラルキーTilemapに戻り　先程設定したソートレイヤーをTileMapに変更する
Sorting Layerとは2Dのオブジェクト同士の描写する順番を取り決めるもの　上にあればあるほど先に描画されるようになる
つまりTileMapを上にもってくることで奥に表示されるということ　ただしカメラからの距離が同じだった場合に限る
本来であれば座標マップを奥に持っていけば良いはずですが　このようにしないと直らない場合があったのでレイヤーでなんとかしているというわけです

やること　ぶつかったら折り返す処理
ヒエラルキーenemy_walk1を選択した状態で右クリックー空のオブジェクトを作成　名前：trigger
triggerを選択した状態でコンポーネントを追加から🔍BoxCollider2dで２Dボックスコライダーを追加する

ボックスコライダー２Dの形を細長くする　サイズXを0.07  Y 1.7 敵の前にもってくる

 ↑この中に何かが入ったら反転するようにする
Box Collider 2D　トリガーにするis Trigger☑を入れる

接地判定の時と同じようにチェックするためのスクリプトを作成する
スクリプトー作成ーC＃スクリプトー名前：EnemyCollisionCheck

C＃スクリプトー名前：EnemyCollisionCheck 　エネミーコリジョンチェック
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyCollisionCheck : MonoBehaviour
{
    /// <summary>									//②説明
    /// 判定内に敵か壁がある
    /// </summary>
    [HideInInspector] public bool isOn = false;				//①パブリックで他のスクリプトから読めるようにフラグを用意して

    private string groundTag = "Ground";					//③地面と
    private string enemyTag = "Enemy";					//④敵と

    #region//接触判定									//⑤↑と接触した時を判定する

    private void OnTriggerEnter2D(Collider2D collision)		//⑥オントリガーエンターと
    {
        if(collision.tag == groundTag || collision.tag == enemyTag)
        {
            isOn = true;									//フラグのオン
        }
    }

    private void OnTriggerExit2D(Collider2D collision)		//イクジットエンターで
    {
        if (collision.tag == groundTag || collision.tag == enemyTag)
        {
            isOn = false;									//フラグのオフ
        }
    }
    #endregion
}
=====================
接地判定の時のように厳密に判定する必要はないのでステイでの判定は行いません。　ENTERとEXITのみ
これで判定する側のスクリプトは完成

今度は↑スクリプトを敵側のスクリプトで読み込むようにする

Enemy_Zako1
=====================
public class Enemy_Zako1 : MonoBehaviour
{
    #region//インスペクターで設定する
    [Header("移動速度")] public float speed;
    [Header("重力")] public float gravity;
    [Header("画面外でも行動するか")] public bool nonVisible;
    [Header("接触判定")] public EnemyCollisionCheck checkCollision;		//インスペクターで設定できるようにしておく
    #endregion
=====================
void FixedUpdate()
    {
        if (!oc.playerStepOn)
        {
        
            if (sr.isVisible || nonVisible)
            {
                if (checkCollision.isOn)			//判定の中に敵か壁があった場合
                {
                    rightTleftF = !rightTleftF;		//左右を反転するようにする　!はbool型に付けると逆になる　フラグを反対にする
                }
                int xVector = -1;
                if (rightTleftF)
                {
=====================

ヒエラルキーtriggerを選択した状態でインスペクターコンポーネントを追加でEnemy Collision Check(スクリプト)を付ける　
ヒエラルキーenemy_walk1を選択した状態でインスペクターのEnemy_Zako1ー接触判定をtriggerに変更
動きが確認しやすいようにタイルマップで壁を作る　Tilemap選択ーウィンドウー２Dータイルパレット
enemy_walk1右クリックー複製で敵をもう一体追加する
この状態で実行すると敵がオブジェクトに当たった時、反転する



＃４７	シーンを切り替えてみよう
Step17	シーンをロードしてみよう

プロジェクトScenesーSampleScene右クリックー削除

titleScenes ー stage1で移動する
testシーンを保存して　stage1にリネーム　再ロード
titleScenesダブルクリックでタイトルシーンに切り替える　Titleスクリプトを開く　シーンの移動の命令を書くだけの状態となっている

Title スクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;			//①②を使用するにはコレを書く必要がある

public class Title : MonoBehaviour
{
    private bool firstPush = false;

    //スタートボタンを押されたら呼ばれる
    public void PressStart()
    {
        Debug.Log("Press Start!");

        if (!firstPush)
        {
            Debug.Log("Go Next Scene!");
            //ここに次のシーンへ行く命令を書く
            SceneManager.LoadScene("stage1");	//②ステージ１シーンへ移動する
            //
            firstPush = true;
        }
    }
}
=====================
② SceneManager.LoadScene(“シーンの名);は、そのシーンへ移動する
厳密には移動ではなくファイルのアンロード＆ロードとなる　シーンを場面とした場合、移動と言える
このメソッドは以前にボタンから呼び出せるようにしている　ボタンからの呼び出し設定済み

↑ヒエラルキーボタンのインスペクターボタンのクリック時
この状態で実行▶しスタートボタンを押すと下記のエラーとなる
Scene 'stage1' couldn't be loaded because it has not been added to the build settings or the AssetBundle has not been loaded.
To add a scene to the build settings use the menu File->Build Settings...　←シーンの登録を忘れているエラー
何故？　シーンのロードをする為には予めシーンの登録をする必要がある　基本的には　そのためロードできなかった

上メニューのファイルFileービルド設定Build Settings  ビルド設定ウィンドウが開く
シーンを追加Add Open Scenesをクリックすると 今開いてるシーンを登録するこができる　titleScenes
シーンファイルをドラッグアンドドロップすることでも登録することができる　stage1
間違えて登録してしまったものは右クリックで選択を削除Remove Selectionできる  登録解除
ドラッグアンドドロップでシーンの順番を変えることができる　ゲームとしてビルドした時に０番のシーンからゲームが始まる　タイトルシーンを０番に置く
これでシーンの登録は完了　この状態で実行▶するとスタートボタンを押した時、次のシーンへ以降できる


Step18	フェードを実装してみよう
フェードも無限どうりあるので１版簡単なものを実装　今回は一番簡単なやり方で実装していく　Pixelmatorなどで適当に真っ黒な画像を用意#000000
/Users/me-do/Desktop/unity/006		black.png
プロジェクトAssetsーTexture配下にblackを配置　インスペクター　テクスチャタイプをスプライトに　適用
ヒエラルキーCanvas配下にImageを作成　キャンバス右クリックーUIー画像　名前：Fadeに変更
Fadeを選択した状態でImageのソース画像Source Imageにblackをドラッグアンドドロップ
Rect Transform　幅960　高さ540に変更　以前決めた解像度の大きさに　解像度＃３２
Image 画像タイプImage Typeー埋めてあるFilledに変更　塗りつぶし方法Fill Methodー垂直方向Verticalに変更　縦フェードにする
塗りつぶし量Fill Amountを左右に調整すると画層を変化させることができる

やること　フェードをスクリプトから制御できるようにしていく
スクリプトを作成　名前：FadeImage

FadeImageスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;				//①UGUIを使用する時はこれを書く　今回はimageにアクセスするのでコレを書きます

public class FadeImage : MonoBehaviour
{
    private Image img = null;			//②イメージの変数を用意
    private int frameCount = 0;			//④このフェードのｹﾞｰﾑｵﾌﾞｼﾞｪｸﾄがｱｸﾃｨﾌﾞになってから何フレーム経ったのかをカウントする
    private float timer = 0.0f;			//⑦時間を計測する変数を用意
    private bool fadeIn = false;			//⑥フェードインのフラグを作成

    // Start is called before the first frame update
    void Start()
    {
        img = GetComponent<Image>();	//③イメージの変数をゲットコンポーネントする

        //試しにフェードインさせてみる		//⑫一時的にフェードインする処理を追加
        img.color = new Color(1, 1, 1, 1);	//
        img.fillAmount = 1;				//
        img.raycastTarget = true;		//
        fadeIn = true;					//
    }

    // Update is called once per frame
    void Update()
    {
        //シーン移行時の処理の重さでTime.deltaTimeが大きくなってしまうから2フレーム待つ
        if(frameCount > 2)				//⑤２フレーム以上　経っているのかをカウントする
        {
            if (fadeIn)					//⑥
            {
                //フェード中				//⑨
                if (timer < 1f)				//⑦今回は１秒でフェードするようにしていく
                { 
                    img.color = new Color(1, 1, 1, 1 - timer);	//⑧タイマーが１秒以下の場合、白カラーと　画像の色とは違うパラメータ
                    img.fillAmount = 1 - timer;				//⑧フィルアマウントを１から減らしていきます　１は真っ黒
                }						//⑦
                //フェード完了				//⑨
                else									//⑩フェードが完了したら値を指定して
                {
                    img.color = new Color(1, 1, 1, 0);			//Time.deltaTimeの値は変わるので終わったらちゃんと値を指定
                    img.fillAmount = 0;					//０は透明
                    img.raycastTarget = false;				//Imageの当たり判定をオフ
                }
                timer += Time.deltaTime;				//⑪タイマーを動かす
            }							//⑥
        }
        ++frameCount;				//⑤
    }
}
=====================
⑤コレは何をしているかというと　これから時間が進むにつててフェードしていく形で作成
シーンの移動は重い処理なので前フレームからの通過時間が長くなりがち　そのため時間経過が解りづらいので２フレーム待っている　フレーム＃１４
・仮に１秒でフェードする場合
シーン移動←0.5秒かかったとする
↓
Maximun Allowed Timestep 0.3333333(デフォルトの場合)　ゲーム内時間　Time.delta Timeは0.3333333
※コンポーネントの初期化処理などの影響で２フレーム目も重くなりがち
シーン移動から1フレーム0.3333333２フレーム0.6666666経過していることになる　２フレームで７割近く終了
一気に時間が進むのでガクンガクンとフェードする　これはいただけないので２フレーム待つ
＜シーン移動時＞0.6666666秒いきなり進むことが多い　フェードに限らずシーン開始時、秒数で何かをする場合は注意が必要　ゲーム内時間＃３９

⑧Color(R, G, B, A)→(赤、緑、青、透明度)　(0, 0, 0, 1)黒	　(1, 1, 1, 1)白　　Aは0が近いほど透明
UGUIは元々の画像のRGBA ✕ Color(RGBA)=最終的な色を出している　画像(0, 0, 0, 1)黒 ✕ (1, 1, 1, 1)白 = (0, 0, 0, 1)黒  何も変わらない
今回の場合はRGBに何を入れても結果は変わりませんが1, 1, 1つまり白色は掛け算が１なのでもともとの画像と同じになる
白色にする＝元々の画像の色を使う
Aは0が透明であるので1秒かけて透明になる処理になっている

fillAmount とは　黒い画像を　動かせるバー　縦や横に動かせる　さっき動かしていたバー

raycastTargetとは当たり判定を持つことができる（設定が可能な）UGUIに当たり判定をつけるかどうか
フェードして透明になった→透明な画像が上に乗っかっている　透明なものの当たり判定がオンだと下にあるボタンが押すことが出来ない
当たり判定があるものにブロックされてしまうわけです　そのため当たり判定をオフにしています

↑のスクリプトができたらFade ImageスクリプトをヒエラルキーFadeを選択した状態でコンポーネントの追加にドラックアンドドロップ
この状態で実行するとタイトルシーンがフェードインする

フェード完了時にパラメータをセットする

FadeImageスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class FadeImage : MonoBehaviour
{
    private Image img = null;
    private int frameCount = 0;
    private float timer = 0.0f;
    private bool fadeIn = false;
    private bool compFadeIn = false;			//①フェードインが完了したというフラグを作成

    // Start is called before the first frame update
    void Start()
    {
        img = GetComponent<Image>();

        //試しにフェードインさせてみる
        img.color = new Color(1, 1, 1, 1);
        img.fillAmount = 1;
        img.raycastTarget = true;
        fadeIn = true;
    }

    // Update is called once per frame
    void Update()
    {
        //シーン移行時の処理の重さでTime.deltaTimeが大きくなってしまうから2フレーム待つ
        if(frameCount > 2)
        {
            if (fadeIn)
            {
                FadeInUpdate();    		//③フェードイン毎フレームの処理をメソッド化
            }
        }
        ++frameCount;
    }


    private void FadeInUpdate()	//③これからフェードアウトを作成するので見やすいようにメソッド化してスクリプトを移動させる
    {
        if (timer < 1f)
        {
            img.color = new Color(1, 1, 1, 1 - timer);
            img.fillAmount = 1 - timer;
        }
        else
        {
            FadeInComplete();		//④フェードイン完了した時の処理をメソッド化
        }
        timer += Time.deltaTime;
    }							//③

    private void FadeInComplete()	//④フェードコンプリート作成　移動
    {
        img.color = new Color(1, 1, 1, 0);
        img.fillAmount = 0;
        img.raycastTarget = false;
        timer = 0.0f;				//②フェードが完了した時に各種フラグをセット
        fadeIn = false;
        compFadeIn = true;
    }							//④
}
=====================
処理をまとめられたところで今度はフェードアウトを作っていく

FadeImageスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class FadeImage : MonoBehaviour
{
    private Image img = null;
    private int frameCount = 0;
    private float timer = 0.0f;
    private bool fadeIn = false;
    private bool fadeOut = false;					//①フェードアウト用のフラグを作成
    private bool compFadeIn = false;
    private bool compFadeOut = false;				//①

    // Start is called before the first frame update
    void Start()
    {
        img = GetComponent<Image>();
    }

    // Update is called once per frame
    void Update()
    {
        //シーン移行時の処理の重さでTime.deltaTimeが大きくなってしまうから2フレーム待つ
        if(frameCount > 2)
        {
            if (fadeIn)
            {
                FadeInUpdate();    
            }
            else if (fadeOut)							//②フェードアウト時の毎フレームの処理を作成していく
            {
                FadeOutUpdate();
            }
        }
        ++frameCount;
    }

    //フェードイン中								//③
    private void FadeInUpdate()
    {
        if (timer < 1f)
        {
            img.color = new Color(1, 1, 1, 1 - timer);
            img.fillAmount = 1 - timer;
        }
        else
        {
            FadeInComplete();
        }
        timer += Time.deltaTime;
    }


    private void FadeOutUpdate()					//④フェードインと違って今度は時間経過で１に近づいていく形にする
    {
        if(timer < 1f)
        {
            img.color = new Color(1, 1, 1, timer);
            img.fillAmount = timer;
        }
        else
        {
            FadeOutComplete();						//⑦メソッドを呼ぶ
        }
        timer += Time.deltaTime;
    }

    //フェードイン完了								//⑤
    private void FadeInComplete()
    {
        img.color = new Color(1, 1, 1, 0);
        img.fillAmount = 0;
        img.raycastTarget = false;
        timer = 0.0f;
        fadeIn = false;
        compFadeIn = true;
    }

    //フェードアウト完了							//⑥上とほぼ同じ
    private void FadeOutComplete()
    {
        img.color = new Color(1, 1, 1, 1);				//1にする
        img.fillAmount = 1;							//1にする
        img.raycastTarget = false;
        timer = 0.0f;
        fadeOut = false;							//フラグの種類を変える
        compFadeOut = true;
    }
}
=====================
今度は別のスクリプトからフェードインとフェードアウトを呼び出せるようにする

FadeImageスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class FadeImage : MonoBehaviour
{
    [Header("最初からフェードインが完了しているかどうか")] public bool firstFadeInComp;	//⑪インスペクターで設定できるようにする

    private Image img = null;
    private int frameCount = 0;
    private float timer = 0.0f;
    private bool fadeIn = false;
    private bool fadeOut = false;
    private bool compFadeIn = false;
    private bool compFadeOut = false;

    /// <summary>					//③
    /// フェードインを開始する
    /// </summary>
    public void StartFadeIn()			//①
    {
        if(fadeIn || fadeOut)
        {
            return;						//フェード中は新たにフェードを開始しない
        }
        fadeIn = true;					//②フェードを開始するための初期設定
        compFadeIn = false;
        timer = 0.0f;
        img.color = new Color(1, 1, 1, 1);
        img.fillAmount = 1;				
        img.raycastTarget = true;		//Imageの当たり判定をオン（フェード中にボタンを押せないようにする）
    }								//UGUIの当たり判定はUGUIに対してのみ有効　プレイヤーにはフェードは当たらない

    /// <summary>					//⑤
    /// フェードインが完了したかどうか
    /// </summary>
    /// <returns></returns>
    public bool IsFadeInComplete()		//④フェードインが完了したかどうかも他のスクリプトから読めるようにしておく
    {
        return compFadeIn;
    }

    /// <summary>					//⑧
    /// フェードアウトを開始する
    /// </summary>
    public void StartFadeOut()			//⑥フェードアウトも同様にしていく
    {
        if (fadeIn || fadeOut)			//⑦上からコピーしてフェードアウト用に変更する
        {
            return;
        }
        fadeOut = true;
        compFadeOut = false;
        timer = 0.0f;
        img.color = new Color(1, 1, 1, 0);
        img.fillAmount = 0;
        img.raycastTarget = true;
    }

    /// <summary>					//⑩
    /// フェードアウトを完了したかどうか
    /// </summary>
    /// <returns></returns>
    public bool IsFadeOutComplete()	//⑨
    {
        return compFadeOut;
    }

    // Start is called before the first frame update
    void Start()
    {
        img = GetComponent<Image>();		
        if (firstFadeInComp)			//⑫スタートでシーン開始時に　
        {
            FadeInComplete();			//最初からフェードインが完了した状態で始まるか
        }
        else
        {
            StartFadeIn();				//フェードインを始めるかを切り分けて処理
        }
    }

    // Update is called once per frame
    void Update()
    {
        //シーン移行時の処理の重さでTime.deltaTimeが大きくなってしまうから2フレーム待つ
        if(frameCount > 2)
        {
            if (fadeIn)
            {
                FadeInUpdate();    
            }
            else if (fadeOut)
            {
                FadeOutUpdate();
            }
        }
        ++frameCount;
    }

    //フェードイン中
    private void FadeInUpdate()
    {
        if (timer < 1f)
        {
            img.color = new Color(1, 1, 1, 1 - timer);
            img.fillAmount = 1 - timer;
        }
        else
        {
            FadeInComplete();
        }
        timer += Time.deltaTime;
    }


    private void FadeOutUpdate()
    {
        if(timer < 1f)
        {
            img.color = new Color(1, 1, 1, timer);
            img.fillAmount = timer;
        }
        else
        {
            FadeOutComplete();
        }
        timer += Time.deltaTime;
    }

    //フェードイン完了
    private void FadeInComplete()
    {
        img.color = new Color(1, 1, 1, 0);
        img.fillAmount = 0;
        img.raycastTarget = false;
        timer = 0.0f;
        fadeIn = false;
        compFadeIn = true;
    }

    //フェードアウト完了
    private void FadeOutComplete()
    {
        img.color = new Color(1, 1, 1, 1);
        img.fillAmount = 1;
        img.raycastTarget = false;
        timer = 0.0f;
        fadeOut = false;
        compFadeOut = true;
    }
}
=====================
⑪⑫は　黒のフェードが置いてあると他のオブジェクトが見えなくなるので工夫する　このまま置いておくと邪魔
タイトル画面などシーン開始時にフェード演出が必要ないシーンもあるのでインスペクターから設定できるようにする

ヒエラルキーFadeをせんたくした状態でインスペクターの塗りつぶし量Fill Amountを0にする
最初からフェードインが完了しているかどうか☑する　タイトルシーンではフェードイン演出はいらないため
Canvas Renderer 透明メッシュをカリングCull Transparent Mesh☑する
<Cull Transparent Mesh> UGUIが透明な時、その描画をスキップする　透明のものは重い　透明になる可能性のあるUGUIは必ず☑を入れる


今度はスタートボタンを押したらフェードアウトするようにする
タイトルのスクリプトを編集

Titleスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Title : MonoBehaviour
{
    [Header("フェード")] public FadeImage fade;			//①インスペクターからフェードを設定できるようにする

    private bool firstPush = false;
    private bool goNextScene = false;					//②次のシーンへ行くフラグを作成

    //スタートボタンを押されたら呼ばれる
    public void PressStart()
    {
        Debug.Log("Press Start!");

        if (!firstPush)
        {
            Debug.Log("Go Next Scene!");
            fade.StartFadeOut();							//⑤ボタンを押したらフェードアウトが開始するようにする
            firstPush = true;
        }
    }

    private void Update()								//③スタートボタンを押したらフェードアウトするので　アップデートで
    {
        if (!goNextScene && fade.IsFadeOutComplete())		//フェードアウトの完了を監視する
        {
            SceneManager.LoadScene("stage1");			//④上からカットした。フェードアウトが完了したら
            goNextScene = true;							//次のシーンへ行くようにする　一回しか処理しないようにする
        }
    }
}
=====================
ヒエラルキーCanvasを選択した状態でTitleスクリプトのフェードにFade (Fade Image)スクリプトを選択する
この状態で実行するとタイトルボタンからフェードアウトしてシーン移動できるようになる

次はステージ側のシーンでフェードインするようにする

プロジェクトAssets配下で右クリックー作成ーフォルダ　名前：Prefab
ヒエラルキーFadeをPrefabフォルダへドラックアンドドロップしてFadeをプレハブにする　titleScenes右クリックーシーンを保存
プロジェクトAssetsーScenesーstage1をダブルクリックして作業シーンを切り替える

stage1シーンでの作業
ヒエラルキーで右クリックーUIーキャンバスグループを押下　するとCanvasとEventSystemが作成される
ヒエラルキーCanvasを選択した状態でインスペクターCanvasーレンダーモードをスクリーンスペースーカメラに変更
インスペクターレンダーカメラにヒエラルキーMain Cameraをドラックアンドドロップ
インスペクターCanvas ScalerのUIスケールモードを画面サイズに拡大Scale With Screen Sizeに変更
参照解像度　X960　Y540に変更

　　　　　↑ヒエラルキーCanvasを選択した状態でインスペクターCanvasの平面の距離Plane Distanceを5に変更する
プレイヤーのステージのZ軸が0の位置にある　カメラは−１０の位置　つまり距離は１０
これはキャンバスがカメラからどれくらいの距離に置くのかというものになる
これをカメラとプレイヤーのステージの間の値になるようにした　※真ん中にする必要はない

ヒエラルキーCanvasを一番下にもってくる
プロジェクトプレハブフォルダのFadeをCanvas配下に配置　キャンバスにドラックアンドドロップ
ヒエラルキーFadeを選択した状態でインスペクターの最初からフェードインが完了しているかどうか☑を外す　ステージシーンではフェードしてほしいから
ヒエラルキーstage1右クリックーシーンを保存してtitleSceneをダブルクリックして戻る

titleSceneシーンでの作業
これで実行▶してスタートボタンを押すとフェードアウトしてフェードインするようになった
Fadeをプレハブにしたので他のシーンでも使える



＃４８	ゲームマネージャー作成
Step19	シングルトンを実装してみよう

ゲームマネージャーを作成
＜ゲームマネージャーとは＞ゲームの進行管理　全体的なパラメータの管理　全ての場所に存在する　ただ一つしか無い　Unityの機能ではない
自分で作るもの　好きなように作ってOK　多くのシーンで使用する機能やパラメータをのせておくと便利
[例]２Dアクションの場合　ステージの進行状況　スコア管理　セーブデータの取り扱い　ゲームマネージャーは必須ではないがあると便利

ゲームマネージャーのスクリプトを作成　名前をGameManagerにすると何故かアイコンが変わる
スクリプトフォルダから右クリック作成ースクリプト　名前：GManager

ゲームマネージャーのスクリプト　GManager
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GManager : MonoBehaviour
{
    public static GManager instance = null;		//①空箱
    public int score;							//⑥試しにパラメータをもたせてみる　スコア
    public int stageNum;						//ステージ
    public int continueNum;					//コンテニュー

    private void Awake()						//②Startによく似たメソッド
    {
        if (instance == null)						//③もしスタティックな変数が空箱だった場合
        {
            instance = this;						//このインスタンスのアドレスを入れる　空箱の中に中身を入れることができた
            DontDestroyOnLoad(this.gameObject);	//④このスクリプト(GManager)が張り付いているゲームオブジェクトはシーン移動で破棄されない
        }
        else									//⑤すでにインスタンスが存在する場合
        {
            Destroy(this.gameObject);				//このゲームオブジェクトを破棄するようにする
        }
    }
}
=====================
①static修飾子とは変数やメソッド、クラスにつけると　それが静的なものとして扱われる
＜静的な＞←動かないもの

動く場合　メモリ　オブジェクトをインスタンス化などで生成するとメモリにのる　
オブジェクトを作成するたびに繰り返されオブジェクトを破棄するとメモリが開放される
＜staticをつけない場合＞その時必要な分メモリに載せて使わなくなったらメモリを開放するもの
メリット：メモリ効率がいい　　デメリット：メモリに載ったり破棄されたりするのでメモリのどこにあるかわからない
(例)GetComponentで捕まえる必要がある等　どこにあるかわからないから探していた　メモリの場所を探す必要がある

動かない場合　メモリ　そのStaticなメソッドやクラスや変数を含む型にアクセスするとメモリに載る
その時、そのスタティックなオブジェクトを含む型のインスタンスが無くてもメモリに載る
今まではオブジェクトが生成されないとメモリに載りませんでしたがスタティックは違う　ちょっとでも触ったらメモリに載る
一度メモリに載ってしまうとゲーム終了時まで破棄されない　動かなくなる　１つしか存在しない

例えばこういうスクリプトを書いたとします
public class Test : MonoBehaviour
{
	int a;
	static int b;
}
↑これを沢山ゲームオブジェクトに貼り付けたとします　Test(Script)✕４　aは４つ　bは１つ　メモリ上
＜static修飾子な場合＞破棄されず、１つしか存在しないものになります
メリット：メモリの確保が最初のみ　メモリの場所が動かないのでアクセスが容易　ゲットコンポーネントなどで探す必要がない
デメリット：ずっとメモリを占有する　そのため使わなくなったら無駄でしか無いものになります

なぜこれをスタティックするのかというと
ゲームマネージャーはほとんどのシーンで使うならメモリを所有していても問題ない
アクセスしやすいのでどこからでも呼び出しやすい　これをpublicにすることでどのスクリプトからでも呼び出せるようにしている
↓丁寧に書くならこう書いたほうがいい
public static GManager Instance { get; private set;}  ゲットセットについては解説しておらず解説の内容がブレるのでこのままでいく

static にすると動かないメモリ領域を確保すると言いましたがnullを代入しています　なぜでしょう
これはstatic変数なのでいわゆる箱になります
これはGManager型なのでつまりこのスクリプトの型なのでスクリプトのインスタンスのアドレスの場所が入る箱となる
ゲームマネージャーそのものをスタティックにしたのではなくゲームマネージャーの場所を示す為の箱をスタティックにしている
この空箱は動かないのでこの中にインスタンスのアドレスを入れておけばどこからでもゲームマネージャーにアクセス可能となる
スタティック変数は確保している領域が動かないだけで中身は自由に動かすことができる

やること　このスタティックな空箱に中身を入れていく
②Awake
Unity側が呼ぶ特別なメソッドでインスタンス化された直後に呼ばれる 　Startによく似たメソッドでStartより先に呼ばれる
③初期化処理を書くことが多い
④＜DontDestroyOnLoad＞とはシーンを移動しても指定したオブジェクトは破棄されなくなる命令です
破棄されないので一回でもインスタンス化されたらデストロイDestroyなどで意図的に破棄しない限りずっと居続けます
①〜⑤このようなやり方をシングルトンと言う
＜シングルトン＞とは絶対に１つしか存在しないものを定義する手法
Unityの機能でもC#の機能でもなくプログラミングのやり方の一種です

＜シングルトンの意味＞なぜシングルトンを使うのか
C＃はオブジェクト指向なので設計図を元にいくらでも実体を作成可能です　しかしいくつも存在されては困るものがある
[例]ステージの進行状況やスコア等　沢山存在したら困ってしまう
というわけでただ１つのが保証されているというのは大事なのです　ではなぜこのように書くんとシングルトンになるのかというと
instanceはスタティックなので何個このスクリプト(GManger.cs)をインスタンス化しても箱は一緒のもの指す 箱の存在は変わらない
つまりGManger.cs１GManger.cs２GManger.cs３と作っていってもこの箱は同じものを指す
その箱が③空ならインスタンスを入れますが⑤既に入っている場合はデストロイする
最初の１つだけは箱に入るが２個めからは破棄されるので必ず１つしか存在しないというわけです
ただしゲームオブジェクトを破棄しているので同じゲームオブジェクトに複数つけると機能しません　※同じゲームオブジェクト複数つけないように注意
ゲームオブジェクトには１つしかつけないようにする

一度インスタンス化してしまえば　それ以降ずっと存在し続けるので全ての場所に存在し、ただ１つしか存在しないという部分を作成した
後は必要な機能をどんどん作って載せていけばOKとなる　⑥


⑥で作ったパラメータを試しに使ってみる

Enemy_Zako1.cs 敵スクリプトのやられた時の処理　※テスト用　次回直す
=====================
if(!isDead)
            {
                anim.Play("dead");
                rb.velocity = new Vector2(0, -gravity);
                isDead = true;
                col.enabled = false;
                GManager.instance.score += 10;
                Destroy(gameObject, 3f);
            }
            else
=====================
このように型.staticなものとするだけでアクセス可能　ゲットコンポーネントがいらない
※publicなので他のスクリプトからでもこうすればアクセス可能となる
instanceはスタティックでしたがscore はスタティックではないはず　何故アクセスできる？
instanceの中に実体がはいっているから
スタティックな箱に入っているアドレス→実体→実体の中のスコアにアクセスしている
そもそも実体にアクセスしているのでスタティックではなくてもアクセスすることができます


ゲームマネージャーをシーンに設置していく
titleScenes上のヒエラルキー右クリックー空のオブジェクトを作成　名前：GameManager
ヒエラルキーGameManagerを選択した状態でコンポーネントを追加にGManagerスクリプトをドラックアンドドロップ
ヒエラルキーのGameManagerをAssetsーPrefabにドラックアンドドロップしてプレハブにする　titleScenesを保存する
プレハブにしたGameManagerを全てのシーンにドラックアンドドロップする（今はstage1のみ）

ただ１つではんかったのでは？　２つ以上存在するとデストロイされるので問題ない　何故全シーンに置くのか　めんどいから
＜ゲームマネージャー＞は一度インスタンス化さえしてしまえばもう消えないので本来最初のシーンのみにあるべき
今回の場合はタイトルシーン　一回はインスタンス化する必要があるので毎回タイトルシーンから始める必要がる
ゲーム中であれば絶対タイトルから始まるが開発中はめんどくさい
どのシーンからスタートしてもいいようにプレハブ化して全部のシーンに置く　
インスタンスをデストロイするのではなくゲームオブジェクトごとデストロイしていた
無駄な処理が入るが開発が楽になる　試しに再生してみる　

実行▶すると
DontDestroyOnLoad
	GameManager
↑ゲームマネージャーは特別な扱いになる　これでシーン移動しても消えないものになっているのがわかる

↑２つあったのが１つになる
先程のスクリプトがちゃんと動いているかを確認する　敵をふんでみる

↑はっちゃん２匹ふんだのでスコアが２０となった　ちゃんと１０づつプラスされている
スコアを画面に表示等は次回解説



＃４９	スコア・残機・アイテム作成
Step20	画面に情報を表示しよう

前回ゲームマネージャーを作成したので　それを使って今回、スコアや残機を作成していく
確認：　stage1		ゲームビュー　解像度の設定　（960✕540） Canvasの設定　スクリーンスペース　メインカメラ　５　動画では19.87
↑これらをちゃんとしないとUIがズレる　解像度＃３２　キャンバス＃３３
確認：　titleScenes	Text　Font Sizeはなるべく揃えた方がいい　＃３３　これらの点に気をつけて開発していく
タイトルシーンのフォントサイズ大86→90（タイトル）　中60　小26→30（ボタン）に変更した

stage1	
テキストを配置していく
ヒエラルキーCanvasを選択した状態で右クリックーUiーテキスト 名前：Score
ヒエラルキーCanvas配下のTextを選択した状態でインスペクターText 水平オーバーフローをOverflow 垂直オーバーフローをOverflow
フォントサイズを90　色をイエローに変更する　整列の左は右端そえ　右は真ん中を選択  テキストはScoreに変更

　　　　  ↑右端揃えにすると数字の桁数が増えても位置がずれたりしなくなる

↑拡大/縮小を全て0.7に変更して右上はじにスコアテキストを配置する
プロジェクトScriptから新たにスクリプトを作成　名前：Score

スコア　スクリプトをビジュアルスタジオで開く
Score.cs　←名前はそのままにした
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;									//①UGUIのテキストを使用するので書く

public class Score : MonoBehaviour
{
    private Text scoreText = null;							//②スコアのテキスト変数
    private int oldScore = 0;								//③古いスコアを保存しておく変数

    // Start is called before the first frame update
    void Start()
    {
        scoreText = GetComponent<Text>();					//④ゲットコンポーネントでインスタンスを捕まえて
        if(GManager.instance != null)							//ゲームマネージャーがあるのかどうかをチェックする　置き忘れてるとデータが取れない
        {
            scoreText.text = "Score " + GManager.instance.score;	//⑤表示する文字を格納している変数　ここに表示する文字を入れていく
        }
        else												//
        {
            Debug.Log("ゲームマネージャー置き忘れてるよ！");		//⑥ゲームマネージャーがないとこのスクリプトは動かない為、ログに出して
            Destroy(this);									//自身を消す
        }
        
    }

    // Update is called once per frame
    void Update()
    {
        if(oldScore != GManager.instance.score)				//⑦現在のスコアが変わった時だけテキストを更新する
        {
            scoreText.text = "Score " + GManager.instance.score;	//
            oldScore = GManager.instance.score;				//
        }
    }
}
=====================

ヒエラルキーScoreを選択した状態でScoreスクリプトをコンポーネント追加にドラックアンドドロップしてスクリプトをスコアオブジェクトに貼り付ける
↓UIの表示をFadeより奥になるようにする

実行▶して確認すると特に問題なく動いている　スコアの表示ができた

やること　スコアを加算する物を作る　敵のスクリプトを編集する　前回ゲームマネージャーがちゃんと機能しているかを見るために簡単に作成したが、今回はちゃんと作る

Enemy_Zako1スクリプト
=====================
#region//インスペクターで設定する
    [Header("加算スコア")] public int myScore;			//①加算するスコアをインスペクターで設定できるようにする
    [Header("移動速度")] public float speed;
    [Header("重力")] public float gravity;
    [Header("画面外でも行動するか")] public bool nonVisible;
    [Header("接触判定")] public EnemyCollisionCheck checkCollision;
    #endregion
=====================
↓やられた時の処理
=====================
if(!isDead)
            {
                anim.Play("dead");
                rb.velocity = new Vector2(0, -gravity);
                isDead = true;
                col.enabled = false;
                if (GManager.instance != null)				//②インスペクターで設定したスコアを加算するようにすうる
                {
                    GManager.instance.score += myScore;	//
                }
                Destroy(gameObject, 3f);
            }
=====================
ヒエラルキーenemy_zako1を選択した状態でヒエラルキーEnemy_Zako1スクリプト　加算スコアを20にする　enemy_zako1（1）も同様にする
ヒエラルキーstage1　プロジェクトAssetsーTexture配下にあるpng画像を全てチェックする☑iOS用に上書き
titleBackGroundの画像が２のべき乗になっていない警告を消す為、形式をRGB(A) Compressed ASTC 4×4 blockに設定する　適用←警告が消える
画像の容量を抑えたい - ロバメモ - 素人のUnity覚書と奮闘記	unity only pot textures can be compressed  Unityではポットテクスチャのみ圧縮可能
２のべき乗　１，２，４，８，１６，３２，６４，１２８，２５６，５１２，１０２４，２０４８，４０９６


スコアアイテム作成
https://poromi-free.net/category/food-drink/sushi/
↑イラストの里からブリの画像を拝借　PixelmatorでPixelmatorで幅128→512 高さ128→512 解像度960に設定する

↑これをstar.pmgとして保存しTextureにドラックアンドドロップ　インスペクターでテクスチャタイプをスプライトにする
画像が大きいのでヒエラルキーのstarを選択した状態でインスペクター拡大/縮小を　X0.3　Y0.3　Z0.3にする

プレイヤーが判定内に入ったかどうかのスクリプトを作成する
名前：PlayerTriggerCheck　プレイヤートリガーチェック
敵の衝突判定のスクリプトをコピー　EnemyCollisionCheck とほとんど同じ
判定をプレイヤーに対して行うように変更する
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerTriggerCheck : MonoBehaviour
{
    /// <summary>
    /// 判定内にプレイヤーがいる
    /// </summary>
    [HideInInspector] public bool isOn = false;

    private string PlayerTag = "Player";

    #region//接触判定
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.tag == PlayerTag)
        {
            isOn = true;
        }
    }

    private void OnTriggerExit2D(Collider2D collision)
    {
        if (collision.tag == PlayerTag)
        {
            isOn = false;
        }
    }
    #endregion
}
=====================
↑これでプレイヤーが判定内に入っているかを取れるようになった
このスクリプトを使い回せばスコアアイテム以外のものにも流用できる

次にスコアアイテム自体のスクリプトを作成する　名前：ScoreItem

スコアアイテムのスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ScoreItem : MonoBehaviour
{
    [Header("加算するスコア")] public int myScore;						//①インスペクターからスコアと
    [Header("プレイヤーの判定")] public PlayerTriggerCheck playerCheck;	//上のスクリプトを設定できるようにする

    // Update is called once per frame
    void Update()
    {
        //プレイヤーが判定内に入ったら									//②
        if (playerCheck.isOn)										//
        {
            if (GManager.instance != null)								//プレイヤーが判定内に入ったら
            {
                GManager.instance.score += myScore;						//スコアをプラスして
                Destroy(this.gameObject);								//自分自身を破棄する
            }
        }
    }
}
=====================

ヒエラルキーplayerを選択した状態でインスペクター　タグをPlayerに変更

ヒエラルキーstarを選択した状態で
Score Item(Script)					加算するスコア　10入力	プレイヤーの判定　star
とPlayer Trigger Check (Script)					
とBox Collider 2Dを貼り付ける			トリガーにする　☑する　Is Trigger　

テスト用としてstar（ブリだけど）を2ケ複製して適当に並べる　ブリ３つ並べる
この状態で実行▶するとちゃんとスコアが加算される　敵をふんずけた場合もできている　スコアはこれで大丈夫そうだ

ステージ数と残機を表示
↓ステージテキストを表示
stage1ヒエラルキーScore右クリックーコピーー貼り付けー名前:Stage /Scoreの下に配置　インスペクター　テキスト：Stage 00 色：緑　として左上はじに置く
ハートアイコンを作成
色々な色のハートマークのイラスト - イラストの里からグリーンハートを拝借、PixelmatorでPixelmatorで幅512 高さ512 解像度960に設定する
グリーンハートpngを真ん中に貼り付けて、背景のレイヤーの☑を外し、pngで書き出す　006フォルダに保存
画像をプロジェクトTextureに配置　名前：hart インスペクター　テクスチャタイプ　スプライト　☑iOS用　適用
ヒエラルキーCanvas右クリックーUIー画像でImageで配置　ソース画像heart
ヒエラルキーStage右クリックー複製　Imageの子になるように配置し、Imageの名前をHeartに変更　複製したステージの名前はHeartTextにして下記のように配置する

UIとステージ内の物は分ける　(UGUIとSpriteRendererを使う)
UI（Canvas Score Stage）ゲーム内オブジェクト（Heart HeartText）は分けて配置する
残機の数値のテキスト部分はアイコンの子オブジェクトにしている（HeartText）これらはFadeより上に置く

↑スコアとステージの位置と大きさを小さくした　拡大/縮小 0.5
後はこれらを制御するスクリプトを書いていく　StageNum　ステージナムとHeart　ハートで作成が　先ずはゲームマネージャースクリプトを編集する

GManagerスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GManager : MonoBehaviour
{
    public static GManager instance = null;
    public int score;
    public int stageNum;
    public int continueNum;
    public int heartNum;				//①ゲームマネージャーに残機用のパラメータを追加

    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(this.gameObject);
        }
        else
        {
            Destroy(this.gameObject);
        }
    }
}
=====================

残機とステージ数のスクリプトはScoreスクリプトとほぼ同じなのでスコアスプリクトをコピーする
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Score : MonoBehaviour
{
    private Text scoreText = null;
    private int oldScore = 0;

    // Start is called before the first frame update
    void Start()
    {
        scoreText = GetComponent<Text>();
        if(GManager.instance != null)
        {
            scoreText.text = "Score " + GManager.instance.score;
        }
        else
        {
            Debug.Log("ゲームマネージャー置き忘れてるよ！");
            Destroy(this);
        }
    }

    // Update is called once per frame
    void Update()
    {
        if(oldScore != GManager.instance.score)
        {
            scoreText.text = "Score " + GManager.instance.score;
            oldScore = GManager.instance.score;
        }
    }
}
=====================

①StageNumスクリプト(ステージ数)はヒエラルキーStageに追加する　Scoreスクリプトの☑を外す　スコアのコンポーネントを削除
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class StageNum : MonoBehaviour
{
    private Text stageText = null;
    private int oldStageNum = 0;

    // Start is called before the first frame update
    void Start()
    {
        stageText = GetComponent<Text>();
        if (GManager.instance != null)
        {
            stageText.text = "Stage " + GManager.instance.stageNum;
        }
        else
        {
            Debug.Log("ゲームマネージャー置き忘れてるよ！");
            Destroy(this);
        }
    }

    // Update is called once per frame
    void Update()
    {
        if (oldStageNum != GManager.instance.stageNum)
        {
            stageText.text = "Stage " + GManager.instance.stageNum;
            oldStageNum = GManager.instance.stageNum;
        }
    }
}
=====================

②Heartスクリプト(残機)はヒエラルキーHeartTextに追加する　Scoreスクリプトの☑を外す　スコアのコンポーネントを削除
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Heart : MonoBehaviour
{
    private Text heartText = null;
    private int oldHeartNum = 0;

    // Start is called before the first frame update
    void Start()
    {
        heartText = GetComponent<Text>();
        if (GManager.instance != null)
        {
            heartText.text = "× " + GManager.instance.heartNum;
        }
        else
        {
            Debug.Log("ゲームマネージャー置き忘れてるよ！");
            Destroy(this);
        }
    }

    // Update is called once per frame
    void Update()
    {
        if (oldHeartNum != GManager.instance.heartNum)
        {
            heartText.text = "× " + GManager.instance.heartNum;
            oldHeartNum = GManager.instance.heartNum;
        }
    }
}
=====================

↑ヒエラルキーGameManagerを選択した状態でヒエラルキーのスクリプトを設定する
この状態で実行▶すると　とりあえず各種情報を表示することができる　中身については後々作っていく



＃５０	ステージを管理しよう
Step20	元の位置に戻る処理を作ろう

＜ステージ管理でやること＞
・スタート地点から始まる		←今回はココ
・やられたらコンテニュー		←今回はココ
・ゴール時の処理
・ゲームオーバー時の処理

ステージのスタート位置を決めよう　（プレイヤーがやられた時にもどってこられるようにする）
やること　スタート地点を示す目印を作ろう
ヒエラルキー右クリックー空のオブジェクトを作成Create Empty  スタート地点と分かるような名前：StartPos
ヒエラルキーStartPosを選択した状態でインスペクターの下記をクリック

緑色アイコンをクリックすると　あとでオレンジ色に変更した

選択したアイコンの中に名前が入っている状態でシーン上に表示される　シーンビューでしか表示されない　
ゲームオブジェクトにアイコンが付く→開発用の目印になる　これをスタート地点の目印する

↑プレイヤーの座標はデフォルトだと中心になっている　プレイヤーの座標をスタート地点に持っていきたいのでスタート地点は
プレイヤーの半分の長さより地面から高い位置に置く　そうしないと地面にめり込んで変な物理演算が働いた状態からスタートする　目印をつけることができた

やること　スクリプトでスタート地点から始まるようにする
新しいスクリプトを作成　名前：StageCtrl

StageCtrlスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class StageCtrl : MonoBehaviour
{
    [Header("プレイヤーゲームオブジェクト")] public GameObject playerObj;	//①プレイヤーを動かす為に設定
    [Header("コンテニュー位置")] public GameObject[] continuePoint;		//②目印を設定する為　配列＃２２

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
=====================
①プレイヤーの位置をスタート地点に動かしたいのでプレイヤーのゲームオブジェクトをインスペクターから設定できるようにする
②目印にしたゲームオブジェクトを設定するための変数を用意する　
↓何故配列にしたか
空のゲームオブジェクトを作って　名前：StageCtrl　このスクリプト(Stage Ctrl)を貼り付ける
プレイヤーゲームオブジェクト　配列ではないと直接入れられる	Player
コンテニュー位置			配列の場合、変数の横に▶アイコンが付く　これをクリックすると数値を入れるところが出てくる	StartPos
試しに１を入れてみる　すると中身を入れる場所が出てくる
ドラックアンドドロップで各種ゲームオブジェクトを入れる
1の数値を変えると入れられる中身の数が変わる　０番目はスタート地点　Element 0
Element 1からをコンテニューする位置の目印に差し替えることによってコンテニューポイントを通過するごとに番号を1個ずつ増やしていけば復帰ポイントを切り替えられる
ToDo 復帰位置を変更する　コンテニューポイントを通過したとき復帰ポイントをずらしていかないといけない
↑コンテニュー用アイテムを作成した時に解説するので今回は仕組みだけつくっておく
今回は配列の数を１にしてスタート地点への移動だけを考える


StageCtrlスクリプトに戻り、ステージが始まった時プレイヤーをスタート地点へ持ってくるようにする

StageCtrlスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class StageCtrl : MonoBehaviour
{
    [Header("プレイヤーゲームオブジェクト")] public GameObject playerObj;
    [Header("コンテニュー位置")] public GameObject[] continuePoint;

    // Start is called before the first frame update
    void Start()
    {
        if(playerObj != null && continuePoint != null && continuePoint.Length > 0)		//①Headerの設定が足りているかどうかの判定
        {																//①
            playerObj.transform.position = continuePoint[0].transform.position;		//②プレイヤーの位置を0番目の目印（スタート地点）に
        }																//①
        else																//①
        {																//①
            Debug.Log("設定が足りてないよ！");									//①
        }																//①
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
=====================
①設定が足りてないと困るので設定が足りているかどうかの判定をして足りていない場合はログを表示します
②プレイヤーのゲームオブジェクトを先程の配列の０番目に入れた目印つまりスタート地点に移動させれば初期配置は完了

これでプレイヤーが変な位置に居ても実行▶するとちゃんとスタート地点から始まります
うまくいかない場合はスタート地点のZ座標がタイルマップと同じ値か確認　←うまくいかなかった　StartPosのZ軸の値が違った　タイルマップと合わせたらうまくいった
スタート地点から始めることができるようになった

やること　やられたらスタート地点に復帰
「やられたら」の判定を作成　しかしながら今まで書いてきたプレイヤーのスクリプトの中にすでにやられた判定を作ってある　
private bool isDown = false;　←これはやられた瞬間trueになる　←ダウンアニメーションが終わったかどうかわからない
ダウンアニメーションが終わってないのにスタート地点に戻ると変なのでダウンアニメーションの終了判定を作る

プレイヤーのスクリプトに次のメソッドを追加していく

Playerのスクリプト
=====================
/// <summary> アニメーションを設定する
private void SetAnimation()
    {
        anim.SetBool("jump", isJump || isOtherJump);
        anim.SetBool("ground", isGround);
        anim.SetBool("run", isRun);
    }

    /// <summary>						//⑩サマリーを書く
    /// コンテニュー待機状態か				//
    /// </summary>						//
    /// <returns></returns>				//
    public bool IsContinueWaiting()			//⑨ダウンアニメーションが完了しているかどうか　publicで外から読めるようにする
    {									//このままではダウンアニメーションが完了しているかどうかの判定を直接返しているので
        return IsDownAnimEnd();			//あんまり意味のないメソッドになっているが
    }									//後々条件を追加するので下準備としてこのような形にしている
																	
    //ダウンアニメーションが完了しているかどうか//②
    private bool IsDownAnimEnd()			//①プレイヤーのスクリプトにメソッドを追加する
    {									//
        if(isDown && anim != null)			//③そもそもダウンしているかという判定とアニメーターを取得できているかの判定
        { 								//
            AnimatorStateInfo currentState = anim.GetCurrentAnimatorStateInfo(0);	//⑤
            if (currentState.IsName("player_down"))								//⑥
            {																//
                if(currentState.normalizedTime >= 1)								//⑦
                {															//
                    return true;					//⑧条件に当てはまる時trueを返す
                }															//
            }																//
        }								//
        return false;						//④条件に当てはまらない場合はfalseを返す(ダウンアニメーションが完了していないという情報を返す)
    }									//

//接触判定
=====================
⑤アニメーターステートインフォ型の変数を用意しアニメーターからゲットカレントアニメーターステートインフォする
<AnimatorStateInfo>アニメーターの状態の情報を表す型　アニメーターの状態って何？

↑これの状態の情報　これがどのような状態になっているのかという情報を入れる型
その情報を入れる型の中にアニメーターからゲットカレントアニメーターステートインフォというメソッドを使って情報を入れている
<Animator.GetCurrentAnimatorStateInfo>現在再生中のステートの情報を取得するメソッド

↑現在再生中の1つの四角の情報を取得する　要するに現在再生しているアニメーションの情報を取得できる
(0)はアニメーターの0番目のレイヤーの情報を取得するという意味　0番目のレイヤーはデフォルトのもの
２Dでは0番目のレイヤー以外はほとんど使わないので特に深く考えず０と書いてOK　２Dではデフォルトレイヤーしかほとんど使わない

⑥IF文で切り分けて取得してきた情報から.IsNameで判定する

↑現在再生中のコレの名前が指定したものかどうかを判定するということ　player_downが再生中であれば良い
つまり現在再生中の名前がダウンアニメーションのものと一致していればよい
引数にダウンアニメーションの名前を入れてtrueが返ってきたらplayer_downを再生中ということになる

⑦カレントステート.ノーマライズドタイムは１以上という条件で判定する
<AfnimatorStatoInfo.normalizedTime>アニメーションの正規化された再生時間
＜正規化＞・データを扱いやすいように整理・変形すること　・Unity の場合だいたい０〜１の範囲にデータを整理している
<normalizedTime>の場合　再生時間が
0	…	0%再生
0.1	…	10%再生
0.2	…	20%再生
︙	
1	…	100%再生が完了している
>= 1　←コレは100%以上再生完了していた場合という意味になる　すなわちアニメーションが終わっているということ
１より上も判定しているが　これはアニメーションがループすると１より大きい値になるので一応こうしている
ちなみにこの判定方法はダウンアニメーション(player_down)から矢印が出ていないので可能になっている
矢印が出ていると次のアニメーションに移ってしまうので現在再生中のアニメーションが違うものになってしまいます
矢印が出ている場合は別の方法で判定する必要があるので注意

これでプレイヤーがダウンしている時の判定を作ることができた
次はステージ管理のほうでプレイヤーがダウンしていたらスタート地点に戻るようにする　今度はステージを管理するスクリプトを書いていく

StageCtrlスクリプト
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class StageCtrl : MonoBehaviour
{
    [Header("プレイヤーゲームオブジェクト")] public GameObject playerObj;
    [Header("コンテニュー位置")] public GameObject[] continuePoint;

    private Player p;		//①

    // Start is called before the first frame update
    void Start()
    {
        if(playerObj != null && continuePoint != null && continuePoint.Length > 0)
        {
            playerObj.transform.position = continuePoint[0].transform.position;

            p = playerObj.GetComponent<Player>();		//プレイヤーのゲームオブジェクトからプレイヤーのスクリプト取得
            if(p == null)								//
            {
                Debug.Log("プレイヤーじゃない物がアタッチされているよ！");
            }
        }
        else
        {
            Debug.Log("設定が足りてないよ！");
        }
        
    }

    // Update is called once per frame
    void Update()
    {
        if(p != null && p.IsContinueWaiting())			//②プレイヤーが取得できていてコンテニュー待機状態の場合
        {
            if(continuePoint.Length > GManager.instance.continueNum)　//③コンテニューする位置の目印がちゃんと設定されているかをチェックする
            {
                playerObj.transform.position = continuePoint[GManager.instance.continueNum].transform.position;	//④
            }
            else
            {
                Debug.Log("コンテニューポイントの設定が足りてないよ！");
            }
        }
    }
}
=====================
④プレイヤーの位置をゲームマネージャーで管理しているコンテニュー番号の目印の位置へ移動させる（今回は０のみ）

この状態で実行▶するととりあえずやられたら元の位置にもどることができたが　かえるちゃんの位置が中に浮いていたのでStartPosの位置Yを-3に修正
これでは足りないので戻ってきたら復帰するようにする
プレイヤーのスクリプトに戻る

Playerのスクリプト
=====================
  	 return false;
    }

    /// <summary>
    /// コンテニューする
    /// </summary>
    public void ContinuePlayer()	//①コンテニューするメソッドを外から読めるようにpublicで作成
    {
        isDown = false;			//②ダウンから復帰する為にフラグ等のリセットなどをして状態を元の状態に戻す
        anim.Play("player_stand");
        isJump = false;
        isOtherJump = false;
        isRun = false;
    }

//接触判定
=====================

今度はステージを管理するスクリプトのほうで上のメソッドを呼び出します

StageCtrlスクリプト
=====================
// Update is called once per frame
    void Update()
    {
        if(p != null && p.IsContinueWaiting())
        {
            if(continuePoint.Length > GManager.instance.continueNum)
            {
                playerObj.transform.position = continuePoint[GManager.instance.continueNum].transform.position;
                p.ContinuePlayer();		//上のメソッドを読んで状態を復帰
            }
            else
            {
                Debug.Log("コンテニューポイントの設定が足りてないよ！");
            }
        }
    }
=====================
この状態で実行▶すると　とりあえず復帰することができた　しかしこのままでは何が起こっているかよく分からないので演出をつける

プレイヤーの絵を表示しているのはインスペクターのSprite Rendererというコンポーネントです
スプライトレンダラーをオン・オフすると絵を表示したり消したりできる　オン・オフを繰り返せば明滅する演出ができる　これをプログラムで動くようにする

プレイヤーのスクリプトに戻る
Player.cs
=====================
 #region//プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private CapsuleCollider2D capcol = null;
    private SpriteRenderer sr = null;		//①必要な変数を追加
    private bool isGround = false;
    private bool isJump = false;
    private bool isRun = false;
    private bool isHead = false;
    private bool isDown = false;
    private bool isOtherJump = false;
    private bool isContinue = false;		//
    private float continueTime = 0.0f;	//
    private float blinkTime = 0.0f;		//
    private float jumpPos = 0.0f;
    private float otherJumpHeight = 0.0f;
    private float dashTime, jumpTime;
    private float beforeKey;
    private string enemyTag = "Enemy";
    #endregion

　    void Start()
    {
        //コンポーネントのインスタンスを捕まえる
        anim = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
        capcol = GetComponent<CapsuleCollider2D>();
        sr = GetComponent<SpriteRenderer>();		//②スタートでスプライトレンダラーを取得
    }

    private void Update()						//③アップデートメソッドを追加
    {										//
        if (isContinue)							//④コンテニューフラグが立っている時　フラグがオンの時
        {									//
            //明滅　ついている時の戻る				//⑤↑時間経過でオンオフ切り替え
            if(blinkTime > 0.2f)					//
            {									//（オンオフ戻るを繰り返す）
                sr.enabled = true;					//３戻る
                blinkTime = 0.0f;					//
            }									//
            //明滅　消えている時					//
            else if(blinkTime > 0.1f)				//
            {									//
                sr.enabled = false;					//２オフ
            }									//
            //明滅　ついている時					//
            else								//
            {									//
                sr.enabled = true;					//１オン
            }									//
            //1秒たったら明滅終わり					//⑥
            if(continueTime > 1.0f)					//
            {									//
                isContinue = false;					//演出が終わったらリセット
                blinkTime = 0.0f;					//
                continueTime = 0.0f;				//
                sr.enabled = true;					//
            }									//
            else								//
            {									//
                blinkTime += Time.deltaTime;			//演出中は演出用の時間を進める
                continueTime += Time.deltaTime;		//
            }									//
        }									//
    }										//
=====================
③スプライトレンダラーをいじるのは物理演算とは関係ないかつ画面への表示に対する操作なのでフィックスドアップデートではなくアップデートに書く
=====================
/// <summary> コンテニューする
public void ContinuePlayer()
    {
        isDown = false;
        anim.Play("player_stand");
        isJump = false;
        isOtherJump = false;
        isRun = false;
        isContinue = true;						//⑦コンテニューする際に演出用のフラグをオンにする
    }
=====================
この状態で実行▶するとプレイヤーがやられると明滅してスタート地点に復帰することができた
後はやられた時、残機を減らして０でやられるとゲームオーバーを実装すれば大丈夫そうです



＃５１	ゲームオーバーを作ろう
Step21	残機の減算処理を実装しよう

↑空のゲームオブジェクトを作成して　名前：Object　はっちゃんとブリ寿司をその配下に入れた
やること　やられたら残機を減らす　
ゲームマネージャーに処理を追加していく

GManager.cs
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GManager : MonoBehaviour
{
    public static GManager instance = null;

    [Header("スコア")] public int score;						//コメント追加
    [Header("現在のステージ")] public int stageNum;			//コメント追加
    [Header("現在の復帰位置")] public int continueNum;			//コメント追加
    [Header("現在の残機")] public int heartNum;				//コメント追加
    [Header("デフォルトの残機")] public int defaultHeartNum;		//①必要となる変数を追加
    [HideInInspector] public bool isGameOver;				//ゲームオーバーのフラグはインスペクターで表示されないようにする

    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(this.gameObject);
        }
        else
        {
            Destroy(this.gameObject);
        }
    }

    /// <summary>				
    /// 残機を１つ増やす			
    /// </summary>				
    public void AddHeartNum()	//③残機を増やすメソッドを追加
    {							
        if(heartNum < 99)			//上限を超えないように
        {						
            ++heartNum;			
        }						
    }							

    /// <summary>				
    /// 残機を１減らす				
    /// </summary>				
    public void SubHeartNum()	//②残機を減らすメソッドを追加
    {							
        if(heartNum > 0)			
        {						
            --heartNum;			
        }						
        else						
        {						
            isGameOver = true;		//残機が0の状態で呼ばれるとゲームオーバーのフラグをオンにする
        }						
    }							
}
=====================
①デバッグしやすいようにプレイ中も編集可能に　ゲームオーバー用のフラグは編集されたら困るので見えないように

プレイヤーのスクリプトへ移動　 #region//接触判定 　敵と接触した時の処理
Player.cs
=====================
Debug.Log("ObjectCollisionが付いてないよ！");
                    }
                }
                else
                {
                    //ダウンする
                    anim.Play("player_down");
                    isDown = true;
                    GManager.instance.SubHeartNum();		//④上で作ったメソッドを呼び出す
                    break;
                }
=====================
この状態で実行▶すると敵に接触した場合、残機を減らすことができる


ゲームオーバーを実装していきたいのですが、このままだと敵に当たらないといけないのでデバッグが面倒　なので　やられ判定を追加
空のゲームオブジェクト作成　BoxCollider2Dをつける　トリガーする☑Is Trigger　地面の下に長く伸ばして配置　←落下した際のやられ判定にする

お絵かきソフトでトゲを作成　
牛刀包丁のイラスト - イラストの里　で牛刀の絵をパクる　サイズが600 × 519なので５１２でなく１０２４でPixelmatorで作成　名前：toge.png
取り込んでスプライトにしてシーンに配置  ボックスコライダー２D　トリガーする☑　コライダーの編集　包丁の刃に合わせる

タグの追加　DeadArea　HitArea  Tagを変更　落下判定＞DeadArea　トゲ＞HetArea　に変更する

プレイヤーのスクリプトを編集する
Player.cs
=====================
#region//プライベート変数
    private Animator anim = null;
    private Rigidbody2D rb = null;
    private CapsuleCollider2D capcol = null;
    private SpriteRenderer sr = null;
    private bool isGround = false;
    private bool isJump = false;
    private bool isRun = false;
    private bool isHead = false;
    private bool isDown = false;
    private bool isOtherJump = false;
    private bool isContinue = false;
    private bool nonDownAnim = false;			//①変数追加
    private float continueTime = 0.0f;
    private float blinkTime = 0.0f;
    private float jumpPos = 0.0f;
    private float otherJumpHeight = 0.0f;
    private float dashTime, jumpTime;
    private float beforeKey;
    private string enemyTag = "Enemy";
    private string deadAreaTag = "DeadArea";	//
    private string hitAreaTag = "HitArea";		//
    #endregion
=====================
/// <summary> コンテニュー待機状態か			//以前作成したコンテニュー地点へ戻るための判定がダウンアニメーションをしたかどうかでしか
public bool IsContinueWaiting()				//判断していない為、条件を追加する
    {
        if (GManager.instance.isGameOver)		//⑥ゲームオーバーの時はコンテニューしないように
        {
            return false;
        }
        else
        {
            return IsDownAnimEnd() || nonDownAnim;	//ダウンアニメーションをしない場合もコンテニューできるようにする
        }
    }
=====================
/// <summary>
    /// コンテニューする
    /// </summary>
    public void ContinuePlayer()
    {
        isDown = false;
        anim.Play("player_stand");
        isJump = false;
        isOtherJump = false;
        isRun = false;
        isContinue = true;
        nonDownAnim = false;					//⑦コンテニュー時　フラグをリセット
    }

    private void ReceiveDamage(bool downAnim)	//②やられる条件が増えたのでやられたときの処理をメソッド化する
    {
        if (isDown)							//④既にダウン状態でない時、引数からダウンアニメーションをするのかどうかのフラグを受け取り
        {
            return;
        }
        else
        {
            if (downAnim)						//⑤ダウンアニメーションをするか切り分け
            {
                anim.Play("player_down");			//③敵と接触した時のやられ処理を切り取ってこちらへ移動させた
            }
            else
            {
                nonDownAnim = true;
            }
            isDown = true;
            GManager.instance.SubHeartNum();
        }
    }

    #region//接触判定
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.collider.tag == enemyTag)
        {
            //踏みつけ判定になる高さ
            float stepOnHeight = (capcol.size.y * (stepOnRate / 100f));

            //踏みつけ判定のワールド座標
            float judgePos = transform.position.y - (capcol.size.y / 2f) + stepOnHeight;

            foreach (ContactPoint2D p in collision.contacts)
            {
                if (p.point.y < judgePos)
                {
                    //もう一度跳ねる
                    ObjectCollision o = collision.gameObject.GetComponent<ObjectCollision>();
                    if(o != null)
                    {
                        otherJumpHeight = o.boundHeight;//踏んづけたものから跳ねる高さを取得する
                        o.playerStepOn = true;          //踏んづけたものに対して踏んづけた事を通知する
                        jumpPos = transform.position.y; //ジャンプした位置を記録する
                        isOtherJump = true;
                        isJump = false;
                        jumpTime = 0.0f;
                    }
                    else
                    {
                        Debug.Log("ObjectCollisionが付いてないよ！");
                    }
                }
                else
                {
                    ReceiveDamage(true);				//⑧敵に接触した際はダウンアニメーションをtrueにして先程のメソッドを呼び出します
                    break;
                }
            }
        }
    }

    private void OnTriggerEnter2D(Collider2D collision)		//⑨オントリガー２Dでやられ判定外に入った時を追加していく
    {
        if(collision.tag == deadAreaTag)
        {
            ReceiveDamage(false);						//落下判定の時、ダウンアニメーションしない
        }
        else if(collision.tag == hitAreaTag)
        {
            ReceiveDamage(true);						//トゲ判定の時、ダウンアニメーションする
        }
    }

    #endregion
}
=====================
この状態で実行▶するとトゲでダウンしてハートが減り　落ちてダウンせずにハートが減る　を実装できた
無料イラスト うに ウニもいれてみた　toge2

やること　ゲームオーバー作成
プロジェクトTexture配下に真っ黒な画像を用意する　前回作成したblackを流用した
ヒエラルキーCanvas配下で右クリックーUIー画像でImageを作成　名前：GameOver　ソース画像をblackにする　色のA（透明度）をいじって黒の透明度を作成する

blackの解像度は128×128　解像度については＃３２
GameOver配下で右クリックーUIーテキストを押下　Text：Game Over フォントサイズ90　整列２つとも真ん中　水平、垂直オーバーフロー：Overflow 色：赤
GameOver配下で右クリックーUIーX ボタンを押下　形を整える
Button配下で右クリックーUIーテキストを押下  Text：Retry フォントサイズ６０から少し小さくした　
整列２つとも真ん中　水平、垂直オーバーフロー：Overflow 色：黒
これでとりあえずゲームオーバーの表示を作ることができた　UGUIの作り方＃２７
作ったゲームオーバーはFadeより上にする　上にある方が奥に表示されるので　Fadeが上に重なるようにする

次にゲームマネージャーにリトライする為の処理を書いていく
GManager.cs
=====================
/// <summary>
    /// 残機を１減らす
    /// </summary>
    public void SubHeartNum()
    {
        if(heartNum > 0)
        {
            --heartNum;
        }
        else
        {
            isGameOver = true;
        }
    }

    /// <summary>
    /// 最初から始める時の処理
    /// </summary>
    public void RetryGmage()			//リトライした時、各種パラメータやフラグを元に戻す　リトライ時リセットする
    {
        isGameOver = false;
        heartNum = defaultHeartNum;
        score = 0;
        stageNum = 1;
        continueNum = 0;
    }
}
=====================

次にステージコントローラーで

StageCtrl.cs
=====================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;							//⑩シーンに関する処理を書きたいのでこれを書く

public class StageCtrl : MonoBehaviour
{
    [Header("プレイヤーゲームオブジェクト")] public GameObject playerObj;
    [Header("コンテニュー位置")] public GameObject[] continuePoint;
    [Header("ゲームオーバー")] public GameObject gameOverObj;		//①必要な変数を用意する
    [Header("フェード")] public FadeImage fade;					//

    private Player p;
    private int nextStageNum;									//
    private bool startFade = false;								//
    private bool doGameOver = false;							//
    private bool retryGame = false;								//
    private bool doSceneChange = false;							//

    // Start is called before the first frame update
    void Start()
    {
        if(playerObj != null && continuePoint != null && continuePoint.Length > 0 && gameOverObj != null && fade != null) //②設定項目チェック追加
        {
            gameOverObj.SetActive(false);							//③初期設定ではゲームオーバーは非アクティブに
            playerObj.transform.position = continuePoint[0].transform.position;
            p = playerObj.GetComponent<Player>();
            if(p == null)
            {
                Debug.Log("プレイヤーじゃない物がアタッチされているよ！");
            }
        }
        else
        {
            Debug.Log("設定が足りてないよ！");
        }
    }

    // Update is called once per frame
    void Update()
    {
        //ゲームオーバー時の処理								//④ゲームオーバーのフラグがtrueになったらゲームオーバーをアクティブにする
        if(GManager.instance.isGameOver && !doGameOver)		//
        {												//
            gameOverObj.SetActive(true);						//フラグがtrueになったらゲームオーバーをアクティブ
            doGameOver = true;								//
        }												//
        //プレイヤーがやられた時の処理							//
        else if(p != null && p.IsContinueWaiting() && !doGameOver)//⑤ゲームオーバーになっていたらプレイヤーがやられた時の処理を行わないようにする
        {
            if(continuePoint.Length > GManager.instance.continueNum)
            {
                playerObj.transform.position = continuePoint[GManager.instance.continueNum].transform.position;
                p.ContinuePlayer();
            }
            else
            {
                Debug.Log("コンテニューポイントの設定が足りてないよ！");
            }
        }

        //ステージを切り替える								//⑨
        if (fade != null && startFade && !doSceneChange)		//
        {												//
            if (fade.IsFadeOutComplete())						//フェードが完了した後、
            {												//
                //ゲームリトライ									//
                if (retryGame)									//
                {											//
                    GManager.instance.RetryGame();				//リトライの処理を完了する
                }											//
                //次のステージ									//
                else											//
                {											//
                    GManager.instance.stageNum = nextStageNum;	//次のステージへ行く場合の処理
                }											//
                SceneManager.LoadScene("stage" + nextStageNum);	//⑪リトライやステージ移動に(ステージ＋番号)でシーン移動するようにする
                doSceneChange = true;							//
            }												//
        }												//
    }

    /// <summary>									//⑧リトライを押した時はステージ１にシーン移動するようにする
    /// 最初から始める									//
    /// </summary>									//
    public void Retry()								//
    {												//
        ChangeScene(1); //最初のステージ１に戻るので１		//
        retryGame = true;								//
    }												//

    /// <summary>									//⑥シーンを移動するためのメソッドを用意
    /// ステージを切り替えます							//	
    /// </summary>									//
    /// <param name="num">ステージ番号</param>		//
    public void ChangeScene(int num)					//引数で番号を指定　番号を指定してシーンを移動するようにしている
    {												//
        if(fade != null)									//
        {											//
            nextStageNum = num;							//⑦シーン移動するための下準備とフェードの開始のみを行う
            fade.StartFadeOut();							//
            startFade = true;								//
        }											//
    }												//
}
=====================
⑧現在作成されているシーンは２つだけですが　ここからステージ２、ステージ３と増やす際にシーン名に規則性があるとプログラムから動かしやすい
stage2,stage3		stage + 番号　としているのでシーンの移動を番号で行うことが出来るようになります
ちなみに今開いているシーンを開き直すことも可能で開き直すとそのシーンは初期状態に戻る　ステージ１でリトライしても問題ない

プレイヤーのスクリプトに移動する

Player.cs
=====================
void FixedUpdate()
    {
        if (!isDown && !GManager.instance.isGameOver)		//①ゲームオーバー時　移動できないようにする
        {
            //接地判定を得る
            isGround = ground.IsGround();
            isHead = head.IsGround();

            //各種座標軸の速度を求める
            float xSpeed = GetXSpeed();
            float ySpeed = GetYSpeed();

            //アニメーションを適用
            SetAnimation();

            //移動速度を設定
            rb.velocity = new Vector2(xSpeed, ySpeed);
        }
        else
        {
            rb.velocity = new Vector2(0, -gravity);
        }
    }
=====================

インスペクターの設定をする
unity2へ続く


















